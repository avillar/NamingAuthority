
Open Geospatial Consortium Inc.  

Date:  2009-03-25 

Reference number of this OGC® Project Document: OGC 08-068r2 

Version: 1.0.0 

Category: OpenGIS® Interface Standard 

Editor:  Peter Baumann 

Web Coverage Processing Service (WCPS) Language 
Interface Standard 

 
 
 

 

Copyright © 2009 Open Geospatial Consortium, Inc. All Rights Reserved. 
To obtain additional rights of use, visit http://www.opengeospatial.org/legal/. 

 

 

 

 

 

 

 

 

Document type: OpenGIS® Interface Standard 
Document subtype: Extension Package 
Document stage: Approved 
Document language: English 
 

 1 

http://www.opengeospatial.org/legal/


 

ii Copyright © 2012 Open Geospatial Consortium 
 

License Agreement 

Permission is hereby granted by the Open Geospatial Consortium, ("Licensor"), free of charge and subject to the terms set forth below, 
to any person obtaining a copy of this Intellectual Property and any associated documentation, to deal in the Intellectual Property 
without restriction (except as set forth below), including without limitation the rights to implement, use, copy, modify, merge, publish, 
distribute, and/or sublicense copies of the Intellectual Property, and to permit persons to whom the Intellectual Property is furnished to 
do so, provided that all copyright notices on the intellectual property are retained intact and that each person to whom the Intellectual 
Property is furnished agrees to the terms of this Agreement. 

If you modify the Intellectual Property, all copies of the modified Intellectual Property must include, in addition to the above 
copyright notice, a notice that the Intellectual Property includes modifications that have not been approved or adopted by LICENSOR. 

THIS LICENSE IS A COPYRIGHT LICENSE ONLY, AND DOES NOT CONVEY ANY RIGHTS UNDER ANY PATENTS 
THAT MAY BE IN FORCE ANYWHERE IN THE WORLD. 

THE INTELLECTUAL PROPERTY IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
PURPOSE, AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. THE COPYRIGHT HOLDER OR HOLDERS INCLUDED 
IN THIS NOTICE DO NOT WARRANT THAT THE FUNCTIONS CONTAINED IN THE INTELLECTUAL PROPERTY WILL 
MEET YOUR REQUIREMENTS OR THAT THE OPERATION OF THE INTELLECTUAL PROPERTY WILL BE 
UNINTERRUPTED OR ERROR FREE. ANY USE OF THE INTELLECTUAL PROPERTY SHALL BE MADE ENTIRELY AT 
THE USER’S OWN RISK. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR ANY CONTRIBUTOR OF 
INTELLECTUAL PROPERTY RIGHTS TO THE INTELLECTUAL PROPERTY BE LIABLE FOR ANY CLAIM, OR ANY 
DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING 
FROM ANY ALLEGED INFRINGEMENT OR ANY LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF 
CONTRACT, NEGLIGENCE OR UNDER ANY OTHER LEGAL THEORY, ARISING OUT OF OR IN CONNECTION WITH 
THE IMPLEMENTATION, USE, COMMERCIALIZATION OR PERFORMANCE OF THIS INTELLECTUAL PROPERTY. 

This license is effective until terminated. You may terminate it at any time by destroying the Intellectual Property together with all 
copies in any form. The license will also terminate if you fail to comply with any term or condition of this Agreement. Except as 
provided in the following sentence, no such termination of this license shall require the termination of any third party end-user 
sublicense to the Intellectual Property which is in force as of the date of notice of such termination. In addition, should the Intellectual 
Property, or the operation of the Intellectual Property, infringe, or in LICENSOR’s sole opinion be likely to infringe, any patent, 
copyright, trademark or other right of a third party, you agree that LICENSOR, in its sole discretion, may terminate this license 
without any compensation or liability to you, your licensees or any other party. You agree upon termination of any kind to destroy or 
cause to be destroyed the Intellectual Property together with all copies in any form, whether held by you or by any third party. 

Except as contained in this notice, the name of LICENSOR or of any other holder of a copyright in all or part of the Intellectual 
Property shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Intellectual Property without 
prior written authorization of LICENSOR or such copyright holder. LICENSOR is and shall at all times be the sole entity that may 
authorize you or any third party to use certification marks, trademarks or other special designations to indicate compliance with any 
LICENSOR standards or specifications. 

This Agreement is governed by the laws of the Commonwealth of Massachusetts. The application to this Agreement of the United 
Nations Convention on Contracts for the International Sale of Goods is hereby expressly excluded. In the event any provision of this 
Agreement shall be deemed unenforceable, void or invalid, such provision shall be modified so as to make it valid and enforceable, 
and as so modified the entire Agreement shall remain in full force and effect. No decision, action or inaction by LICENSOR shall be 
construed to be a waiver of any rights or remedies available to it. 

None of the Intellectual Property or underlying information or technology may be downloaded or otherwise exported or reexported in 
violation of U.S. export laws and regulations. In addition, you are responsible for complying with any local laws in your jurisdiction 
which may impact your right to import, export or use the Intellectual Property, and you represent that you have complied with any 
regulations or registration procedures required by applicable law to make this license enforceable 
  



Warning 

OGC official documents use a triple decimal-dot notation (i.e. MM.xx.ss). This document 
may be identified as MM.xx (Major.minor) and may include increments to the third dot 
series (schema changes) without any modification to this document, or the version dis-
played on the document. This means, for example, that a document labelled with versions 
1.1.0 and 1.1.1 or even 1.1.9 are exactly the same except for modifications to the official 
schemas that are maintained and perpetually located at: http://schemas.opengis.net/. Note 
that corrections to the document are registered via corrigendums. A corrigendum will 
change the base document and notice will be given by appending a c# to the version 
(where # specifies the corrigendum number). In corrigendums that correct both the sche-
mas and the base document, the third triplet of the document version will increment and 
the ‘c1’ or subsequent identifier will be appended, however the schemas will only in-
crease the third triplet of the version.  

This document is an OGC Standard. Recipients of this document are invited to submit, 
with their comments, notification of any relevant patent rights of which they are aware 
and to provide supporting documentation.

http://schemas.opengis.net/


Contents Page 

1 Scope ................................................................. Error! Bookmark not defined. 
2 Compliance ...................................................... Error! Bookmark not defined. 
3 Normative references ...................................... Error! Bookmark not defined. 
4 Terms and definitions ..................................... Error! Bookmark not defined. 
5.1  Symbols (and abbreviated terms) ................................................................... 2 
5.2  UML notation ................................................................................................... 2 
5.3  Platform-neutral and platform-specific specifications ................................. 2 
6.1  Coverage model ................................................................................................ 3 
6.1.1  Coverages ....................................................................................................... 3 
6.1.2  Dimensions ..................................................................................................... 3 
6.1.3  Locations ........................................................................................................ 4 
6.1.4  Domain ........................................................................................................... 4 
6.1.5  Range values and types ................................................................................. 5 
6.1.6  Null and interpolation................................................................................... 6 
6.2  Coverage probing functions summary ........................................................... 6 
6.3  Restrictions relative to the WCS coverage model ......................................... 8 
7.1  Expression syntax ............................................................................................. 9 
7.1.1  processCoveragesExpr ................................................................................. 9 
7.1.2  processingExpr ............................................................................................ 11 
7.1.3  storeCoverageExpr ..................................................................................... 11 
7.1.4  encodedCoverageExpr ................................................................................ 12 
7.1.5  scalarExpr .................................................................................................... 13 
7.1.6  booleanScalarExpr ...................................................................................... 13 
7.1.7  numericScalarExpr ..................................................................................... 13 
7.1.8  stringScalarExpr ......................................................................................... 14 
7.1.9  coverageExpr ............................................................................................... 14 
7.1.10  getMetaDataExpr ........................................................................................ 14 
7.1.11  setMetaDataExpr ........................................................................................ 15 
7.1.12  coverageIdentifier ....................................................................................... 17 
7.1.13  inducedExpr ................................................................................................ 18 
7.1.14  unaryInducedExpr ...................................................................................... 19 
7.1.15  unaryArithmeticExpr ................................................................................. 19 
7.1.16  trigonometricExpr ...................................................................................... 21 
7.1.17  exponentialExpr .......................................................................................... 23 
7.1.18  boolExpr ....................................................................................................... 25 
7.1.19  castExpr ....................................................................................................... 26 
7.1.20  fieldExpr ...................................................................................................... 27 
7.1.21  binaryInducedExpr ..................................................................................... 28 
7.1.22  rangeConstructorExpr ............................................................................... 33 
7.1.23  subsetExpr ................................................................................................... 34 
7.1.24  trimExpr ...................................................................................................... 35 
7.1.25  extendExpr ................................................................................................... 37 

 



OGC 08-068r2 

7.1.26  sliceExpr ....................................................................................................... 38 
7.1.27  scaleExpr ...................................................................................................... 40 
7.1.28  crsTransformExpr ...................................................................................... 42 
7.1.29  coverageConstructorExpr .......................................................................... 44 
7.1.30  coverageConstantExpr ............................................................................... 46 
7.1.31  condenseExpr .............................................................................................. 49 
7.1.32  generalCondenseExpr ................................................................................. 49 
7.1.33  reduceExpr .................................................................................................. 51 
7.2  Expression evaluation .................................................................................... 52 
7.2.1  Evaluation sequence .................................................................................... 52 
7.2.2  Nesting .......................................................................................................... 52 
7.2.3  Parentheses .................................................................................................. 52 
7.2.4  Operator precedence rules ......................................................................... 53 
7.2.5  Range type compatibility and extension ................................................... 53 
7.3  Evaluation exceptions ..................................................................................... 55 
7.4  processCoveragesExpr response ................................................................... 55 
 

Tables Page 

Table 1  – Coverage domain dimension types. ................................................................. 3 
Table 2  – Coverage range field data types. ..................................................................... 6 
Table 3  – Coverage probing functions. ........................................................................... 6 
Table 4  – reduceExpr definition via generalCondenseExpr .......................................... 51 
Table 5  – Type extension sequence. .............................................................................. 54 
 

iv  



OGC 08-068r2 

i. Preface 

The OGC® Web Coverage Processing Service (WCPS) defines a protocol-independent 
language for the extraction, processing, and analysis of multi-dimensional coverages 
representing sensor, image, or statistics data.  

Suggested additions, changes, and comments on this standard are welcome and encour-
aged. Such suggestions may be submitted by email message or by making suggested 
changes in an edited copy of this document. 

ii. Submitting organizations 

The following organizations have submitted this Interface Standard to the Open Geospa-
tial Consortium, Inc. 

 Jacobs University Bremen 

iii. Document Contributor Contact Points 

  
 

Name Organization  
Peter Baumann Jacobs University Bremen, 

rasdaman GmbH 

iv. Revision history 

Date Release Author Paragraph modified Description 
2008-04-29 0.0.1 Peter Baumann created from 07-151r1 and 08-059r3
2008-09-01 0.0.2 Peter Baumann Many Final version following adoption 
2008-09-22 0.0.3 Peter Baumann Result type specs More accurate phrasing, not just table 

reference
2009-01-08 1.0.0 Peter Baumann many Reworked scalar operations; incorporated 

e-vote comments; fixed syntax inconsis-
tencies; final editorial brush-up 

v. Changes to the OpenGIS® Abstract Specification 

The OpenGIS® Abstract Specification does not require any changes to accommodate the 
technical contents of this (part of this) document. 

 v 



OGC 08-068r2 

vi. Future Work 

This WCPS framework will be enhanced and extended incuding the following features: 

1) WCPS is based on the conceptual model of OGC WCS and OGC Abstract Topic 
6. As the revision of WCS and Abstract Topic 6 proceeds, WCPS will have to be 
adapted to maintain coherence. 

2) In particular, the GeneralDomain is making its way into WCS 1.2; once this is ac-
cepted, WCPS has to be adapted to the agreed shape and usage of GeneralDo-
main. 

3) Add support for further coverage types beyond equidistant grids. 

4) Add support for inserting, updating, and deleting coverages through expressions 
(harmonized with WCS-T). 

5) Refine metadata probing functions. 

6) Extend metadata querying functionality to non-primitive data structure elements. 

7) Establish a WPS profile for WCPS (in a separate specification document). 

vi  



OGC 08-068r2 

Foreword 

The WCPS language standard evolved from an earlier Best Practice Paper [OGC 07-
157r1], and supersedes that document. This document does not supersede any other pre-
viously approved OGC document. 

This document includes two normative Annexes, A and B. 

Attention is drawn to the possibility that some of the elements of this document may be 
the subject of patent rights. The Open Geospatial Consortium Inc. shall not be held re-
sponsible for identifying any or all such patent rights. 

Recipients of this document are requested to submit, with their comments, notification of 
any relevant patent claims or other intellectual property rights of which they may be 
aware that might be infringed by any implementation of the standard set forth in this 
document, and to provide supporting documentation. 

 vii 



OGC 08-068r2 

viii  

Introduction 

The OGC Web Coverage Processing Service (WCPS) defines a language for retrieval and 
processing of multi-dimensional geospatial coverages representing sensor, image, or sta-
tistics data. Services implementing this language provide access to original or derived 
sets of geospatial coverage information, in forms that are useful for client-side rendering, 
input into scientific models, and other client applications. 

WCPS relies on the coverage model as defined in OGC Abstract Specification Topic 6 
“Schema for Coverage Geometry and Functions “ [OGC 07-011] and the OGC Web Cover-
age Service (WCS) Standard [OGC 07-067r5] where coverages are defined as “digital 
geospatial information representing space-varying phenomena”, currently constrained to 
equally spaced grids. 

The WCPS language is independent from any particular request and response encoding, 
as no concrete request/response protocol is specified by WCPS. For setting up a WCPS 
instance, therefore, a separate, additional specification establishing the concrete protocol 
is required. This allows embedding of WCPS into different target service frameworks. 

One such target framework is OGC WCS. Together with the pertaining request type defi-
nition [OGC 08-059r3] WCPS forms an extension of the Web Coverage Service (WCS) 
version 1.1.2 Standard [OGC 07-067r5]. With small changes, this extension is expected 
to also apply to subsequent versions of WCS.  

NOTE A WPS profile of the WCPS language is under preparation.  



 OGC 08-068r2

 

 1 

Open Geospatial Consortium Interface:  
Web Coverage Processing Service (WCPS) 

1 Scope  

This document defines a protocol-independent language for retrieving and processing 
geospatial coverage data.  

Like WCS, WCPS is currently limited to quadrilateral grid coverages, providing informa-
tion at the grid points, usually with interpolation between these grid points.  

NOTE For future versions of this standard it is intended to extend WCPS to incorporate further cover-
age types defined in the OGC Abstract Specification Topic 6 “Schema for Coverage Geometry and Func-
tions" [OGC document 07-011, in synchronization with WCS. 

2 Compliance 

Annex A (normative) specifies compliance tests which shall be tested by any service 
claiming to implement WCPS. 

3 Normative references 

The following normative documents contain provisions that, through reference in this 
text, constitute provisions of this standard. For dated references, subsequent amendments 
to, or revisions of, any of these publications do not apply. For undated references, the lat-
est edition of the normative document referred to applies. 

IETF RFC 2616, Hypertext Transfer Protocol -- HTTP/1.1 

ISO 8601:2000, Data elements and interchange formats — Information interchange — 
Representation of dates and times 

OGC 05-007r7, Web Processing Service Implementation Standard, version 1.0.0 

OGC 06-121r3, OpenGIS® Web Services Common Standard, version 1.1.0 

NOTE  This OWS Common Standard contains a list of normative references that are also applicable to 
this Interface Standard. 

OGC 07-011, Abstract Specification Topic 6: Schema for Coverage Geometry and Func-
tions, version 7.0 



OGC 08-068r2 
 

OGC 07-067r5, OpenGIS® Web Coverage Service Implementation Standard, version 
1.1.2 

NOTE  The WCS standard cited contains a list of normative references that are also applicable to this 
extension standard. 

OGC 07-092r1, Definition identifier URNs in OGC namespace, version 1.1.2 

OGC 08-053r2, WCS Processing Extension Abstract Test Suite, version 1.0.0 

OGC 08-059r3, WCS Processing Extension, version 1.0.0 

4 Terms and definitions 

For the purposes of this document, the terms and definitions given in the above refer-
ences (in particular: WCS [OGC 07-067r5]) apply. 

5 Conventions 

5.1 Symbols (and abbreviated terms) 

Most of the abbreviated terms listed in Subclause 5.1 of the OWS Common Standard [OGC 
06-121r3] also apply to this document. 

Further, this document assumes familiarity with the terms and concepts of the Web Coverage 
Service Standard [OGC 07-067r5]. 

5.2 UML notation 

All the diagrams that appear in this standard are presented using the Unified Modeling Lan-
guage (UML) static structure diagram, as described in Subclause 5.2 of the OGC Web Ser-
vices Common Standard [OGC 06-121r3]. 

5.3 Platform-neutral and platform-specific specifications 

In terms of Clause 10 of OGC Abstract Specification Topic 12 “OpenGIS Service Archi-
tecture” (which contains ISO 19119), this document includes only Distributed Comput-
ing Platform-neutral specifications. This document specifies each operation request and 
response in platform-neutral fashion. This is done using a semi-formal approach to recur-
sively specifying the language syntax and semantics. To assist this, the coverage model is 
formalized as well (but not changed over WCS OGC 07-067r5]). 

The specified platform-neutral data could be encoded in many alternative ways, each ap-
propriate to one or more specific DCPs. One service embedding and encoding is defined 
in the WCS Processing Extension [08-059r3]. Other encodings may specify an API (Ap-
plication Programming Interface approach) with actually no networks communication 
involved between “client” and “server”. 

2 
 



OGC 08-068r1 

6 Conceptual coverage model 

The coverage model of WCPS relies on the coverage model of WCS [OGC 07-067r5] 
and formalizes it in a way which is suitable for expressing the semantics of the operations 
in Section 7.1. Subclause 6.2 describes the constituents of a WCPS coverage by defining 
a set of coverage probing functions. Some restrictions that apply with regard to general 
WCS coverages are listed in Section 6.3. 

NOTE The coverage model specified in this section serves as an interim substitute for a more forma-
lized overall WCS coverage model; once said model is in place it will replace this section. 

6.1 Coverage model 

6.1.1 Coverages 

A coverage consists of a set of locations bearing some value. Following the mathematical 
notion of a function that maps elements of a domain (here: spatio-temporal1 coordinates) 
to a range (here: “pixel”, “voxel”, … values), the set of coverage locations bearing values 
is called the coverage domain while the set of possible values, i.e., the coverage value 
data type, is called the coverage range. 

A coverage domain with its set of locations (or coordinates) is aligned along some d-
dimensional grid where d>0 is called the coverage’s dimensionality. The coordinate 
space, i.e. the set of all possible coordinates, is spanned by d independent dimension 
axes. A dimension axis (abbreviated also as dimension or as axis) is identified by its 
name which is unique within the coverage. The set of all dimension axis names of a cov-
erage C is obtained via the function dimensionNameSet(C). 

6.1.2 Dimensions 

Each dimension has an dimension type associated, which is one of the elements listed in 
Table 1. A coverage can have at most one x, y, z, and t dimension. 

Table 1 – Coverage domain dimension types. 

Dimension 
type 

Meaning 

x East-West extent, expressed in the coverage’s CRS 
y North-South extent, expressed in the coverage’s CRS 
z  Geographical elevation, i.e., height or depth 
t Time 

 

Each dimension shall have one or more coordinate reference systems (CRSs) associated, 
one of them being – according to WCS – either an ImageCRS or a GridCRS (henceforth 
                                                 
1 And in future, once the corresponding extension to WCS is available, abstract axes without spatiotemporal semantics 

 3
 



OGC 08-068r2 
 

collectively termed the Image CRS). Any number of further CRSs can be associated with 
a coverage dimension, given by the set crsSet(C,a). Image CRS and further CRSs togeth-
er determine the set of CRSs which can be used in coordinate-aware operations. Time 
coordinates coordinates shall be expressed as strings adhering to [ISO 8601:2000]. 

NOTE An image CRS always allows to address a coverage in all dimensions. For the other CRSs, 
however, several CRSs together may be necessary to fully address a coverage – for example, WGS84 only 
knows x and y and thus does not allow to specify z and t coordinates in a 4-D x/y/z/t climate model. 

The WCPS service does not need to publish the mapping between coordinates of the dif-
ferent supported CRSs. 

6.1.3 Locations 

A location L is a set  

LC = { (a,c,p) | a∈dimensionNameSet(C), c∈crsSet(C), p∈DimensionPointValues }  

consisting of dimension names, per dimension the coordinate system used, and a coordi-
nate relative to this dimension and CRS; each of the coverage’s dimension name shall 
appear exactly once in this set. The set DimensionPointValues is a generalization of nu-
meric and string values that allows to express all kind of coordinates, including geo-
graphic floating-point coordinates and date/time strings.  

Example For dimension type t, encoding follows [ISO 8601:2000] as described in WCS [OGC 07-
067r5] Table 16, 17 and owsTime (that is, the possible values are ASCII strings). For an image CRS, en-
coding will be integer for all dimension types, and for x/y type geographic coordinates it will usually be 
float. 

On each dimension a total ordering relation “≤” shall be available under all CRSs used. 

Example On a t dimension, this ordering relation will yield true for the following comparison: 

   “Sun Jan 1 23:59:59 CET 2006” 
 ≤ “Tue Dec 5 22:17:48 CET 2006” 

Along each dimension a coverage is delimited by a lower and upper bound value, these 
border values being part of the coverage extent. Location addresses always are relative to 
a particular coverage. 

6.1.4 Domain  

The set of all locations contained in a coverage forms its domain. A domain’s location set 
always is non-empty. It can be described, for each dimension, by a lower and upper 
bound (lo,hi) expressed in one of the coverage’s CRSs applicable for this dimension 
where lo≤hi.  

For a coverage C, function domain() describes its domain structure, which is a set of di-
mension descriptions consisting of dimension name, dimension type, CRS used, and the 
lower and upper bound of the coverage domain expressed in the CRS at hand:  

4 
 



OGC 08-068r1 

domain( C ) = { (a,t,c,lo,hi) | a∈dimensionNameSet(C), t∈{x,y,z,time},  
  c∈crsSet(C), lo,hi∈DimensionPointValues, lo≤hi } 

A location L is inside the domain of a coverage C if its coordinates are inside the domain 
extent under all CRSs supported: 

Let  

C be a coverage, 
LC be a location wrt. coverage C  
  with LC = { (a,c,p) | a∈dimensionNameSet(C), c∈crsSet(C), 
p∈DimensionPointValues }, 
GC be the domain of coverage C  
 with GC = { (a,t,c,lo,hi) | a∈dimensionNameSet(C), t∈{x,y,z,time},  
                     c∈crsSet(C), lo,hi∈DimensionPointValues, lo≤hi }. 

Then, 

LC inside GC  
if and only if  
  for all (a,c,p)∈LC there is some lo,hi∈DimensionPointValues such that: 
   (a,t,c,lo,hi)∈GC  and lo≤p ≤hi relative to CRS c 

6.1.5 Range values and types 

The value associated with a particular location within a coverage, in short: its point val-
ue, can be obtained with probing function value(C,lC) which is defined for every location 
lC ∈imageCrsDomain(C) and lC inside domain(C).  

All grid point values of a coverage share the same type, the coverage’s range type. Ad-
missible types consist of named components called fields; each field is identified by a 
field name unique for the coverage on hand and bears one of the (atomic) numeric or 
Boolean types enumerated in the set RangeFieldTypes (see Table 2): 

RangeFieldTypes = { boolean, char, unsigned char, short, unsigned short, int, un-
signed int, long, unsigned long, float, double, complex, complex2 } 

NOTE 1 This is a restriction over WCS [OGC 07-067r5], see Subclause 6.3. 

NOTE 2 It is not required that all range fields within a coverage are of the same type. 

NOTE 3 Range fields are also known as “bands” or “channels”. 

A coverage’s range type description can be obtained by function rangeType() which de-
livers a set of pairs of field names and field type: 

rangeType(C) = { (f,t) | f ∈ rangeFieldNames(C), t ∈ RangeFieldTypes } 

 

 5
 



OGC 08-068r2 
 

Table 2 – Coverage range field data types. 

Range data type name Meaning 

boolean Boolean  
char 8-bit signed integer 
unsigned char 8-bit unsigned integer 
short 16-bit signed integer 
unsigned short 16-bit unsigned integer 
int 32-bit signed integer 
unsigned int 32-bit unsigned integer 
long 64-bit signed integer 
unsigned long 64-bit unsigned integer 
float Single precision floating point number 
double Double precision floating point number 
complex Single precision complex number 
complex2 Double precision complex number 

 

6.1.6 Null and interpolation 

The set of a coverage’s values to be interpreted as null is obtained via probing function 
nullSet(). This set can be empty. 

Probing function interpolationSet(C) returns a set of pairs (im,nr) where im indicates the 
interpolation type and nr the null resistance employed. This set can be empty. 

Interpolation method defaults associated with a coverage can be obtained through prob-
ing function interpolationDefault(). 

6.2 Coverage probing functions summary 

A set of so-called probing functions allows to extract the constituents listed above from a 
given coverage. These functions are not part of the WCPS interface standard, but serve 
for the sole purpose of defining the semantics of ProcessCoverages requests in Clause 
7.1. 

Table 3 lists the probing functions provided. 

For notational convenience in this document, on the list and set valued items the usual list 
and set functions are assumed for extraction and manipulation, such as union, inter-
section. Further, application of some function to a list or set which is defined on the ele-
ments denotes simultaneous application of this function to all list or set elements. 

Table 3 – Coverage probing functions. 

Coverage  
characteristic 

Probing function  
for some coverage C 

Comment  

Identifier  identifier(C ) For original coverages only, not for 

6 
 



OGC 08-068r1 

processed coverage results   
Grid point values   value(C,p )  

 for all p ∈ imageCrsDomain(C ) 
The coverage grid point (“pixel”), 
“voxel”, …) values, of data type ran-
geType(C ) 

  
Domain dimension 
list 

 dimensionList(C ) List of all of the coverage’s dimension 
names, in their proper sequence 

Domain dimension 
type 

 dimensionType( C, a )  Dimension type  

Image CRS  imageCRS(C ) Image CRS of the coverage, allowing 
direct grid point addressing 

Domain extent of 
coverage, expressed 
in Image CRS 

 imageCrsDomain(C ) Extent of the coverage in (integer) grid 
coordinates, relative to the coverage’s 
Image CRS2; essentially, the set of all 
point coordinates inside the coverage 

Domain extent of 
coverage along di-
mension, expressed 
in Image CRS 

 imageCrsDomain(C, a ) 
 for some a ∈ dimensionList(C ) 

Extent of the coverage in (integer) grid 
coordinates, relative to the coverage’s 
Image CRS, for a given dimension; 
essentially, the set of all values inside 
the extent interval 

CRS set  crsSet(C, a ) 
 for some a ∈ dimensionList(C ) 

Set of all CRSs from the supported 
CRS (see [OGC 07-067r5] Describe-
Coverage) 

extent of coverage 
along dimension, ex-
pressed in arbitrary 

RS C

 domain(C, a, c )  
 for some a ∈ dimensionList(C )
 and some c ∈ crsSet(C ) 

domain of the coverage, expressed in 
one of its CRSs, for a given (spatial, or 
temporal) dimension 

  
Range data type  rangeType(C ) The data type of the coverage’s grid 

point values, given as a set of pairs of 
field Name and (atomic) data type 

Range field type  rangeFieldType(C, f )  
for some f∈rangeFieldNames(C)

The data type of one coverage range 
field, given as some atomic type name 

Range field name set  rangeFieldNames(C ) Set all of the coverage’s range fields 
names   

Null value set  nullSet(C,r ) 
 for all r ∈ rangeType(C ) 

The set of all values that represent null 
as coverage range field value 

  
Default interpolation 
method 

 InterpolationDefault(C,r ) 
 for all r ∈ rangeType(C ) 

Default interpolation method, per cov-
erage field 

Interpolation method 
set 

 interpolationSet(C,r ) 
 for all r ∈ rangeType(C ) 

All interpolation methods applicable to 
the particular coverage range field; 
must list at least the default inter-
polation method 

Interpolation type  interpolationType(im ) 
 for all im ∈ interpolationList(C) 

Interpolation type of a particular inter-
polation method; possible values are 
listed in WCS [OGC 07-067r5] Table 
I.7 

                                                 
2 Note that the same image CRS is supported by all axes of a coverage. 

 7
 



OGC 08-068r2 
 

Null resistance  nullResistance(im ) 
 for all im ∈ interpolationList(C) 

Null resistance level of a particular 
interpolation methods; possible values 
are listed in WCS [OGC 07-067r5] 
Table I.8 

 

Example For a set of numbers {-1, 0, 1} the abs() function produces: 
  abs( {-1, 0, 1} ) = { abs(-1), abs(0), abs(1) } = { 0, 1 } 
…while for a list (-1, 0, 1) the abs() function produces: 
  abs( (-1, 0, 1) ) = ( abs(-1), abs(0), abs(1) ) = ( 1, 0, 1 ) 

NOTE Operations in WCPS rely solely on the structural information when performing semantic 
checks, i.e., on structural compatibility in operations. Ensuring semantic interoperability of coverage do-
mains and ranges is not within the current scope of WCPS. 

6.3 Restrictions relative to the WCS coverage model 

The following WCS coverage features are not supported by this version of WCPS: 

- Range field types in WCPS are constrained to the set indicated in Table 2 whereas 
WCS allows any kind of data structure for range fields.  

NOTE 1 This is necessary to concisely fix the semantics of operations on the range types. 

NOTE 2 In practice this should hardly pose a restriction, as at least all numeric types occurring 
in the applications perceived are provided. 

- Range field components in WCPS are atomic. 

NOTE This is believed to cover most practical cases, and allows to emulate the remaining cas-
es. 

7 WCPS coverage processing language 

The WCPS coverage processing language allows WCPS clients to request processing of 
one or more coverages available on a WCPS server. A WCPS server evaluates an 
expression and returns an appropriate response to the client. The result returned to the 
client upon a successful request consists of an ordered sequence of one or more coverag-
es or scalar values. 

A WCPS processing request consists of a processCoveragesExpr (see Subclause 7.1.1). 
Each WCPS server shall implement the coverage processing operation as specified in the 
following subclauses. 

NOTE 1 While the WCS GetCoverage operation allows retrieval of a coverage from a coverage 
offering, possibly modified through operations like spatial, temporal, and band subsetting and coordinate 
transformation, the WCPS language extends this functionality through more powerful processing 
capabilities. This includes, on the one hand, further coverage processing primitives and, on the other hand, 
nesting of function application, thereby allowing for arbitrarily complex requests. 

NOTE 2  WCPS has been designed so as to be “safe in evaluation” – i.e., implementations are possible 
where any valid WCPS request can be evaluated in a finite number of steps, based on the operation 
primitives. Hence, WCPS implementations can be constructed in a way that no single request can render 

8 
 



OGC 08-068r1 

the service permanently unavailable. Notwithstanding, it still is possible to send requests that will impose 
high workload on a server. 

NOTE 3 Data items within a WCPS response list can be heterogeneous in size and structure. In particu-
lar, the coverages within a response list can have different dimensions, domains, range types, etc. Howev-
er, a response always consists of either coverages or scalar values. 

NOTE 4 As the functionality of WCPS centers around coverage processing, metadata are considered 
only to the extent necessary for a coherent service. This way WCPS keeps orthogonal to other OGC stan-
dards. 

7.1 Expression syntax 

The WCPS primitives plus the nesting capabilities form an expression language, which is 
independent from any particular encoding, and collectively is referred to as WCPS lan-
guage. In the following subsections the language elements are detailed. The complete 
syntax is listed in Appendix B. 

A WCPS expression is called admissible if and only if it adheres to the WCPS language 
definition. WCPS servers shall return an exception in response to a WCPS request that is 
not admissible. 

Example  The coverage expression  

C * 2 

is admissible as it adheres to WCPS syntax whereas  

C C 

seen as a coverage expression violates WCPS syntax and, hence, is not admissible. 

The semantics of a WCPS expression is defined by indicating, for all admissible expres-
sions, the value of each coverage constituent as defined in Subclause 6.2. 

An expression is valid if and only if it is admissible and it complies with the conditions 
imposed by the WCPS language semantics. 

Example  The coverage expression following is valid if and only if the WCPS offers a coverage with 
identifier C that has a numeric field named red. 

C.red * 2.5 

NOTE In the remainder of this section, tables are used to describe the effect of an operation on each 
coverage constitutent. For the reader’s convenience an extra column “Changed?” is provided containing an 
“X” character whenever the operation changes the resp. constituent, and left blank whenever the operation 
does not affect the resp. constituent. 

7.1.1 processCoveragesExpr 

The processCoveragesExpr element processes a list of coverages in turn.  

 9
 



OGC 08-068r2 
 

Each coverage is optionally checked first for fulfilling some predicate, and gets selected 
– i.e., contributes to an element of the result list – only if the predicate evaluates to true. 
Each coverage selected will be processed, and the result will be appended to the result 
list. This result list, finally, is returned as the ProcessCoverages response unless no ex-
ception was generated. 

Let  

v1, … vn be n pairwise different iteratorVars (n ≥1), 
L1, … Ln be n coverageLists (n ≥1), 
b be a booleanScalarExpr possibly containing occurrences of one or more vi 
(1≤i≤n), 
P be a processingExpr possibly containing occurrences of vi (1≤i≤n). 

Then,  

for any processCoveragesExpr E, 
 where 
  E  = for v1 in ( L1 ), 
        v2 in ( L2 ), 
        … , 
        vn in ( Ln ) 
    where b 
    return P 

the result R of evaluating processCoverageExpr E is constructed as follows: 

Let R be the empty sequence; 
while L1 is not empty: 
{ assign the first element in L1 to v1; 
  while L2 is not empty: 
 { assign the first element in L2 to v2; 
  … 
   while Ln is not empty: 
   { assign the first element in Ln to vn; 
    evaluate b and P, substituting any occurrence  
     of coverage identifier vi by the corresponding coverage; 
    if (b)  
    then 
     append evaluation result to R; 
     remove the first element from Ln; 
    } 
  … 
   } 
  remove the first element from L2; 
 } 

10 
 



OGC 08-068r1 

 remove the first element from L1; 
} 

The elements contained in the coverageList clause, constituting coverage identifiers, are 
taken from the coverage identifiers advertised by the server.  

NOTE In a WCS framework such information can be obtained via a GetCapabilities request. 

Coverage identifiers may occur more than once in a coverageList. In this case the cover-
age shall be inspected each time it is listed, respecting the overall inspection sequence. 

Example Assume a WCPS server offers coverages A, B, and C. Then, the server may execute the fol-
lowing WCPS request: 

for $c in ( A, B, C ) 
return tiff( $c ) 

to produce a result list containing three TIFF-encoded coverages tiff(A), tiff(B), tiff(C). 

Example Assume a WCPS server offers satellite images A, B, and C and a coverage M acting as a mask 
(i.e., with range values between 0 and 1). Then, masking each satellite image can be performed with a re-
quest like the following: 

for $s in ( A, B, C ), 
    $m in ( M ) 
return tiff( $s * $m ) 

7.1.2 processingExpr 

The processingExpr element is either a encodedCoverageExpr (which evaluates to an 
encoded coverage; see Subclause 7.1.4), or a storeCoverageExpr (see Subclause 7.1.3), 
or a scalarExpr (which evaluates to coverage description data or coverage summary da-
ta; see Subclause 7.1.5). 

7.1.3 storeCoverageExpr 

The storeCoverageExpr element specifies that an encoded coverage result as described 
by its E sub element is not to be delivered immediately as response to the request, but to 
be stored on server side for subsequent retrieval. The result of the storeCoverageExpr 
expression is the URL under which the result is provided by the server, and the server 
returns only the XML response part with the URL(s) being in place of the coverage(s) 
generated. 

Let  

E be an encodedCoverageExpr. 

Then,  

 11
 



OGC 08-068r2 
 

for any URI U  
where 
  U =  store ( E  ) 

U is defined as that URI at which the coverage result is made available by the 
server. 

Example The following expression will deliver the URL under which the server stores the TIFF-encoded 
result coverage C: 

store( encode( C, “TIFF” ) ) 

NOTE  It is not specified in this standard for how long server-side stored coverages remain available; 
usually they will be deleted after some implementation dependent time to free server space. Future versions 
of this standard may offer means to address this. 

7.1.4 encodedCoverageExpr 

The encodedCoverageExpr element specifies encoding of a coverage-valued request 
result by means of a data format and possible extra encoding parameters. 

Data format encodings should, to the largest extent possible, materialise the coverage’s 
metadata. A service may store further information as part of the encoding. 

Example For a georeferenced coverage, a GeoTIFF result file should contain the coverage’s geo coordi-
nate and resolution information. 

NOTE For materialization of the coverage grid values, the coverage’s image CRS shall be used by 
default. See crsTransformExpr (Subclause 7.1.28) for controlling coverage grid values via other CRSs. 

Let  

C be a coverageExpr, 
f be a string, 
where 
 f  is the name of a data format allowed for C, 
 the data format specified by f supports encoding of a coverage of C’s do-
main and range. 

Then,  

for any byteString S  
where S is one of 
  Se =  encode ( C , f ) 
  See =  encode ( C , f, extraParams ) 
with extraParams being a string enclosed in double quotes (‘”’) 

S is defined as that byte string which encodes C into the data format specified by 
formatName and the optional extraParams. Syntax and semantics of the 
extraParams are not specified in this standard. 

12 
 



OGC 08-068r1 

NOTE 1 In a WCS framework, the data encoding formats supported can be obtained from the suppor-
tedFormats list contained in the response a GetCapabilities request. 

NOTE 2  Some format encodings may lead to a loss of information. 

NOTE 3 The extraParams are data format and implementation dependent. 

Example The following expression specifies retrieval of coverage C encoded in HDF-EOS: 

encode( C, ”hdf-eos” ) 

Example  A WCPS implementation may encode a JPEG quality factor of 50% as the string “.50”. 

Usage of formats shall adhere to the regulations set forth in OGC 07-067r5 Subclause 
9.3.2.2. The sequence of axes used for linearizing arrays for encoding shall be done as 
governed by some corresponding data format encoding specification. 

Example  A data format may specify that x and y axes are linearized to achieve a row-major ordering of 
coverage cells. 

7.1.5 scalarExpr 

The scalarExpr element is either a getMetaDataExpr (see Subclause 7.1.10) or a con-
denseExpr (see Subclause 7.1.31) or a booleanScalarExpr (see Subclause 7.1.6) or a 
numericScalarExpr (see Subclause 7.1.7) or a stringScalarExpr (see Subclause 7.1.7).  

NOTE As such, it returns a result which is not a coverage. 

NOTE A future version of WCPS may support further scalar operations beyond those summarized as 
scalarExprs. 

7.1.6 booleanScalarExpr 

The booleanScalarExpr element is a scalarExpr (see Subclause 7.1.5) whose result 
type is Boolean.  

Operations provided are the well-known Boolean functions and, or, xor, and not bear-
ing the standard semantics. 

7.1.7 numericScalarExpr 

The numericScalarExpr element is a scalarExpr (see Subclause 7.1.5) whose result 
type is numeric (i.e., an integer, float, or complex number), such as numeric constants or 
number-valued metadata retrieval functions.  

Operations provided are the well-known arithmetic (+, -, *, /) and comparison (>, <, >=, 
<=, =, !=) operations bearing the standard mathematical semantics. The rounding func-
tion, round(), rounds a real (not complex) number to the next integer number towards 
zero. 

 13
 



OGC 08-068r2 
 

7.1.8 stringScalarExpr 

The stringScalarExpr element is a scalarExpr (see Subclause 7.1.5) whose result type 
is character string of length greater or equal to zero, such as string constants or string-
valued metadata retrieval functions.  

Operations provided are the well-known string comparison operations = and != bearing 
the standard semantics. In addition, a string-valued getMetadata operation is a stringSca-
larExpr. 

7.1.9 coverageExpr 

The coverageExpr element is either a coverageIdentifier (see Subclause 7.1.12), or 
setMetaDataExpr (see Subclause 7.1.11), or an inducedExpr (see Subclause 7.1.13), or 
a subsetExpr (see Subclause 7.1.23), or a crsTransformExpr (see Subclause 7.1.28), or 
a scaleExpr (see Subclause 7.1.27), or a coverageConstructorExpr (see Subclause 
7.1.29), or a coverageConstantExpr (see Subclause 7.1.30), or a condenseExpr (see 
Subclause 7.1.31). 

A coverageExpr always evaluates to a single coverage. 

7.1.10 getMetaDataExpr 

The getMetaDataExpr element extracts a coverage description element from a coverage. 

NOTE  The grid point value sets (“pixels”, “voxels”, …) can be extracted from a coverage using sub-
setting operations (see Subclause 7.1.22).  

Let  

C be a coverageExpr. 

Then,  

The following metadata extraction functions are defined, whereby the result is 
specified in terms of the coverage’s probing functions as defined in Table 3: 

 Metadata function 
 (for some coverage C,  
 dimension a, range field r) 

Result (in terms of 
probing functions) 

Result type 

identifier(C) identifier(C) Name 

imageCrs(C) imageCRS(C) URN 

imageCrsDomain(C,a) imageCrsDomain(C,a) (lower bound, upper 
bound) integer pair 

crsSet(C) crsSet(C,a) Set of URNs 

14 
 



OGC 08-068r1 

domain(C,a,c) domain(C,a,c) (lower bound, upper 
bound) numeric / 
string pair 

nullSet(C) nullSet(C)  
 

Set of values, each 
structured according 
to rangeType(C); set 
may be empty. 

interpolationDefault(C,r) interpolationDefault(C) Pair of enumeration 
values 

interpolationSet(C,r) interpolationSet(C,a) List of pairs of 
enumeration values 

 
NOTE Not all information about a coverage can be retrieved this way. In a WCS framework, adding 
the information supplied in a GetCapabilities and DescribeCoverage response provides complete informa-
tion about a coverage. 

Example  For some stored coverage named C, the following expression evaluates to “C”: 

identifier( C ) 

7.1.11 setMetaDataExpr 

The setMetaDataExpr element allows to derive a coverage with modified metadata, 
leaving untouched the coverage range values and all metadata not addressed. 

NOTE As WCPS focuses on the processing of the coverage range values, advanced capabilities for 
manipulating a coverage’s metadata are currently not foreseen. 

Let  

C1 be a coverageExpr, 
s be a stringConstant, 
m, n, p be integers with m≥0 and n≥0 and p≥0, 
null be a rangeExpr with null∈nullSet(C1), 
null1, …, nullm be rangeExprs which are cast-compatible with type range-
Type(C1), 
f be an identifier, it an interpolationType, nr a nullResistance with 
f∈rangeFieldNames(C1) and (im,nr)∈interpolationSet(C1,f), 
it1, ..., itn be interpolationTypes, and nr1, ..., nrn be nullResistances with 
fi∈rangeFieldNames(C1) for 1≤i≤n and imi∈interpolationSet(C1,fi), 
crs1, …, crsp be crsNames. 

Then, 

for any coverageExpr C2  
where C2 is one of 

 15
 



OGC 08-068r2 
 

 Cid  =  setIdentifier( C1, s ) 
 Cnull  =  setNullSet( C1, { null1, …, nullm } ) 
 CintDef  =  setInterpolationDefault( C1, f, (im ,nr) ) 
 Cint  =  setInterpolationSet( C1, f, 
                     { (im1,nr1),... , (imn,nrn) } ) 
 Ccrs  =  setCrsSet( C1, { crs1,... , crsp }, a ) 

C2 is defined as follows:  

 Coverage constituent Changed? 

 identifier(C2) =  s for C2=Cid, 
 identifier(C2) =  identifier(C1) otherwise  

X 

 for all p ∈ imageCrsDomain(C2): 
 value(C2, p) =  value( C1, p) 

 

 imageCrs(C2) = imageCrs(C1)  

 imageCrsDomain(C2) = imageCrsDomain(C1)  

 dimensionList(C2) = dimensionList(C1)  

 for all a ∈ dimensionList(C2): 
  crsSet(Cnull, a)  = crsSet(C1, a) 
  crsSet(CintDef, a)  = crsSet(C1, a) 
  crsSet(Cint, a)  = crsSet(C1, a) 
  crsSet(Ccrs, a)  = { crs1,... , crsp } 
  dimensionType(C2, a) = dimensionType(C1, a) 

X 

 for all a ∈ dimensionList(C2), c ∈ crsSet(C2, a): 
  domain(C2, a, c) = domain(C1, a, c) 

X 

 for all fields r ∈ rangeFieldNames(C2): 
 rangeFieldType(C2, r) = rangeFieldType(C1, r) 

 

 nullSet(Cnull )  =  { null1,... , nullm } 
 nullSet(CintDef )  =  nullSet(C1)  
 nullSet(Cint )  =  nullSet(C1)  
 nullSet(Ccrs )  =  nullSet(C1)  

X 

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationDefault(Cnull , r)  = interpolationDefault(C1, r) 
 interpolationDefault(CintDef , r)  = (it,nr) 
  interpolationDefault(Cint , r)  = 
   if interpolationDefault(C1)∈{(im1,nr1),…,(imn,nrn)} 

X 

16 
 



OGC 08-068r1 

   then interpolationDefault(C1, r) 
   else undefined3 
  interpolationDefault(Ccrs , r)  = interpolationDefault(C1, r) 

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationSet(Cnull , r)  = interpolationSet(C1, r) 
 interpolationSet(CintDef , r)  = interpolationSet(C1, r) 
  interpolationSet(Cint , r)  = interpolationSet(C1, r) 
  interpolationSet(Ccrs , r)  =  
  if r=f then {  (im1,nr1), …, (imn,nrn)  } 
  else interpolationSet(C1, r) 
  interpolationSet(Ccrs , r)  =  interpolationSet(C1, r) 

X 

 

Example The following coverage expression evaluates to a coverage that, in its data, resembles C , but 
has no interpolation method available on its range field landUse, allows linear interpolation with full null 
resistance, and quadratic interpolation with half null resistance on C’s range field panchromatic: 

setInterpolation( setInterpolation( C, landUse, { }  ), pan-
chromatic, { linear:full, quadratic:half } ) 

The setNullSet() operation shall not change any preexisting value in the coverage 
(such as in an attempt to adapt old null values to the new ones). 

NOTE Obviously changing a coverage’s null values can render its contents inconsistent. 

A server may respond with an exception if it does not support a CRS specified in a 
setCrsSet() call. 

7.1.12 coverageIdentifier 

The coverageIdentifier element represents the name of a single coverage offered by the 
server addressed.  

Let  

id be the identifier of a coverage C1 offered by the server. 

Then,  

for any coverageExpr C2,  
where 
  C2 =  id 

C2 is defined as follows: 

                                                 
3 An undefined default interpolation method shall lead to a runtime exception whenever it needs to be applied (see 
Clause 6). 

 17
 



OGC 08-068r2 
 

 Coverage constituent Changed? 

 identifier(C2) = identifier(C1) = id  

 for all p ∈ imageCrsDomain(C2): 
 value(C2,p) =  value(C1,p) 

 

 imageCrs(C’) = imageCrs(C1)  

 imageCrsDomain(C2) = imageCrsDomain(C1)  

 dimensionList(C2) = dimensionList(C1)  

 for all a ∈ dimensionList(C2): 
  crsSet(C2, a) = crsSet(C1, a)  
  dimensionType(C2, a) = dimensionType(C1, a) 

 

for all a ∈ dimensionList(C2), c ∈ crsSet(C2, a): 
  domain(C2, a, c) = domain(C2, a, c) 

 

 for all fields r ∈ rangeFieldNames(C2): 
 rangeFieldType(C2, r) = rangeFieldType(C1, r) 

 

 nullSet(C2) =  nullSet(C1)  

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationDefault(C2, r) =  interpolationDefault(C1, r) 

 

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationSet(C2, r) =  interpolationSet(C1, r) 

 

 
Example The following coverage expression evaluates to the complete, unchanged coverage C, assum-
ing it is offered by the server: 

C 

7.1.13 inducedExpr 

The inducedExpr element is either a unaryInducedExpr (see Subclause 7.1.14) or a bi-
naryInducedExpr (see Subclause 7.1.21) or a rangeConstructorExpr (see Subclause 
7.1.22). 

Induced operations allow to simultaneously apply a function originally working on a sin-
gle value to all grid point values of a coverage. In case the range type contains more than 
one component, the function shall be applied to each point simultaneously.  

Whenever a numeric argument is expected (such as a coverage with numeric range 
fields), Boolean false and true shall be interpreted as 0 and 1, resp. Conversely, whenever 

18 
 



OGC 08-068r1 

a Boolean argument is expected (such as a coverage with numeric range fields), then 0 
and 1 shall be interpreted as Boolean false and true, resp. 

Whenever one of the point values (“pixels”, etc.) participating in an induced operation is 
equal to one of the null values of its coverage then the result of the value combination 
shall be one of the values in the participating coverage’s null value set (for a unary in-
duced operation) or one of the values in the null value set intersection of both participat-
ing coverages (for a binary induced operation) if said intersection is not empty. If no null 
value is available (for a unary induced operation) or the intersection of both input cove-
rages’ null values is empty (for a binary induced operation) then the server shall respond 
with a service exception. 

The result coverage has the same domain, but may change its range type.  

NOTE The idea is that for each operation available on the range type, a corresponding coverage op-
eration is provided (“induced from the range type operation”) [1] [2]. 

Example Adding two RGB images will apply the “+” operation to each pixel, and within a pixel to each 
range field in turn. 

7.1.14 unaryInducedExpr 

The unaryInducedExpr element specifies a unary induced operation, i.e., an operation 
where only one coverage argument occurs. 

NOTE  The term “unary” refers only to coverage arguments; it is well possible that further non-
coverage parameters occur, such as an integer number indicating the shift distance in a bit() operation.  

A unaryInducedExpr is either a unaryArithmeticExpr, or trigonometricExpr, or ex-
ponentialExpr (in which case it evaluates to a coverage with a numeric range type; see 
Subclauses 7.1.15, 7.1.16, 7.1.17), a boolExpr (in which case it evaluates to a Boolean 
expression; see Subclause 7.1.18), a castExpr (in which case it evaluates to a coverage 
with unchanged values, but another range type; see Subclause 7.1.19), or a fieldExpr (in 
which case a range field selection is performed; see Subclause 7.1.20). 

7.1.15 unaryArithmeticExpr 

The unaryArithmeticExpr element specifies a unary induced arithmetic operation. 

Let  

C1 be a coverageExpr 

Then,  

for any coverageExpr C2 
where C2 is one of  
  Cplus =  + C1 
 Cminus =  - C1 

 19
 



OGC 08-068r2 
 

 Csqrt =  sqrt( C1 ) 
 Cabs =  abs( C1 ) 

C2 is defined as follows:  

 Coverage constituent Changed? 

 identifier(C2) = “” (empty string) X 

 for all p ∈ imageCrsDomain(C2): 
 value( Cplus, p )  =  value( C1, p ) 
 value( Cminus, p )  =  - value( C1, p ) 
 value( Csqrt, p ) =  sqrt( value( C1, p ) ) 
 value( Cabs, p )  =  abs( value( C1, p ) ) 
 if value(C1,p) ∉ nullSet(C1) 

X 

 imageCrs(C2) = imageCrs(C1)  

 imageCrsDomain(C2) = imageCrsDomain(C1)  

 dimensionList(C2) = dimensionList(C1)  

 for all a ∈ dimensionList(C2): 
  crsSet(C2, a) = crsSet(C1, a)  
  dimensionType(C2, a) = dimensionType(C1, a) 

 

 for all a ∈ dimensionList(C2), c ∈ crsSet(C2, a): 
  domain(C2, a, c) = domain(C2, a, c) 

 

 for all fields r ∈ rangeFieldNames(C2): 

 rangeFieldType(Cplus,r) = rangeFieldType(C1,r) 

 rangeFieldType(Cminus,r) = rangeFieldType(C1,r)  
   if rangeFieldType(Cminus,r) ∈ { char, short, int, long, float,  
   double, complex, complex2 } 
  rangeFieldType(Cminus,r) = char 
   if rangeFieldType(C1,r) = unsigned char, 
 rangeFieldType(Cminus,r) = short 
   if rangeFieldType(C1,r) = unsigned short, 
 rangeFieldType(Cminus,r) = int 
   if rangeFieldType(C1,r) = unsigned int, 
 rangeFieldType(Cminus,r) = long 
   if rangeFieldType(C1,r) = unsigned long 

 rangeFieldType(Csqrt,r) = double 
   if rangeFieldType(C1,r) ∉ { complex, complex2 } 
   and C1.r≥0, 

X 

20 
 



OGC 08-068r1 

 rangeFieldType(Csqrt,r) = complex2 otherwise 

 rangeFieldType(Cabs,r) = rangeFieldType(C1,r) 
   if rangeFieldType(C1,r) ∈ { boolean, unsigned char, 
   unsigned short, unsigned int, unsigned long, float, double } 
  rangeFieldType(Cabs,r) = unsigned char 
   if rangeFieldType(C1,r) = char, 
 rangeFieldType(Cabs,r) = unsigned short 
   if rangeFieldType(C1,r) = short, 
 rangeFieldType(Cabs,r) = unsigned int 
   if rangeFieldType(C1,r) = int, 
 rangeFieldType(Cabs,r) = unsigned long 
   if rangeFieldType(C1,r) = long, 
 rangeFieldType(Cabs,r) = float 
   if rangeFieldType(C1,r) ∈ { float, complex }, 
 rangeFieldType(Cabs,r) = double 
   if rangeFieldType(C1,r) ∈ { double, complex2} 

 nullSet(Cplus)  =  nullSet(C1) 
 nullSet(Cminus)  =  - nullSet(C1) 
 nullSet(Csqrt)  =  sqrt( nullSet(C1) ) 
 nullSet(Cabs)  =  abs( nullSet(C1) ) 
where the resp. operation is applied componentwise to the set. An 
invalid operand (such as negative numbers in case of a square root 
operation) shall lead to a service exception. 

X 

for all r ∈ rangeFieldNames(C2 ): 
  interpolationDefault(C2, r) =  interpolationDefault(C1, r) 

 

for all r ∈ rangeFieldNames(C2 ): 
  interpolationSet(C2, r) =  interpolationSet(C1, r) 

 

 
The server shall respond with an exception if one of the coverage’s grid point values or 
its null values is negative. 

Example The following coverage expression evaluates to a float-type coverage where each range value 
contains the square root of the sum of the corresponding source coverages’ values. 

sqrt( C + D ) 

7.1.16 trigonometricExpr 

The trigonometricExpr element specifies a unary induced trigonometric operation. 

Let  

C1 be a coverageExpr 

 21
 



OGC 08-068r2 
 

Then, 

for any coverageExpr C2  
where C2 is one of 
  Csin =  sin( C1 ) 
 Ccos =  cos( C1 ) 
 Ctan =  tan( C1 ) 
 Csinh =  sinh( C1 ) 
 Ccosh =  cosh( C1 ) 
 Carcsin =  arcsin( C1 ) 
 Carccos =  arccos( C1 ) 
 Carctan =  arctan( C1 ) 

C2 is defined as follows: 

 Coverage constituent Changed? 

 identifier(C2) = “” (empty string) X 

 for all p ∈ imageCrsDomain(C1): 
 value(Csin,p)  =  sin( value(C1,p) ) 
 value(Ccos,p)  =  cos( value(C1,p) ) 
 value(Ctan,p)  =  tan( value(C1,p) ) 
 value(Csinh,p)  =  sinh( value(C1,p) ) 
 value(Ccosh,p)  =  cosh( value(C1,p) ) 
 value(Carcsin,p)  =  arcsin( value(C1,p) ) 
 value(Carccos,p)   =  arccos( value(C1,p) ) 
 value(Carctan,p)   =  arctan( value(C1,p) ) 
 if value(C1,p) ∉ nullSet(C1) 

X 

 ImageCrs(C2) = imageCrs(C1)  

 imageCrsDomain(C2) = imageCrsDomain(C1)  

 dimensionList(C2) = dimensionList(C1)  

 for all a ∈ dimensionList(C2): 
  crsSet(C2, a) = crsSet(C1, a)  
  dimensionType(C2, a) = dimensionType(C1, a) 

 

 for all a ∈ dimensionList(C2), c ∈ crsSet(C2, a): 
  domain(C2, a, c) = domain(C2, a, c) 

 

 for all fields r ∈ rangeFieldNames(C2): 
  rangeFieldType(C2,r) = complex2  
  if rangeFieldType(C1,r) ∈ { complex, complex2 }, ran-
geFieldType(C2,r) = double  

X 

22 
 



OGC 08-068r1 

  otherwise 

 nullSet(Csin)  =  sin( nullSet(C1) ) 
 nullSet(Ccos)  =  cos( nullSet(C1) ) 
 nullSet(Ctan)  =  tan( nullSet(C1) ) 
 nullSet(Csinh)  =  sinh( nullSet(C1) ) 
 nullSet(Ccosh)  =  cosh( nullSet(C1) ) 
 nullSet(Carcsin)  =  arcsin( nullSet(C1) ) 
 nullSet(Carccos)   =  arccos( nullSet(C1) ) 
 nullSet(Carctan)   =  arctan( nullSet(C1) ) 
where the resp. operation is applied componentwise to the set. An 
invalid operand (such as negative numbers in case of a square root 
operation) shall lead to a service exception. 

X 

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationDefault(C2, r) =  interpolationDefault(C1, r) 

 

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationSet(C2, r) =  interpolationSet(C1, r) 

 

 
The server shall respond with an exception if one of the coverage’s grid point values or 
its null values is not within the domain of the function to be applied to it. 

Example The following expression replaces all (numeric) values of coverage C with their sine: 

sin( C ) 

Example To enforce a complex result for real-valued arguments the input coverage can be cast to com-
plex: 

arcsin( (complex) C ) 

7.1.17 exponentialExpr 

The exponentialExpr element specifies a unary induced exponential operation. 

Let  

C1 be a coverageExpr, 
p be a floatConstant 

Then, 

for any coverageExpr C2  
where C2 is one of 
  Cexp =  exp( C1 ) 
 Clog =  log( C1 ) 
 Cln =  ln( C1 ) 
 Cpow =  pow( C1, p ) 

 23
 



OGC 08-068r2 
 

C2 is defined as follows: 

 Coverage constituent Changed? 

 identifier(C2) = “” (empty string) X 

 for all p ∈ imageCrsDomain(C2): 
 value( Cexp, p )  =  exp( value(C1,p) ) 
 value( Clog , p )  =  log( value(C1,p) ) 
 value( Cln , p )  =  ln( value(C1,p) ) 
 value( Cpow, p )  =  value(C1,p)p 

X 

 imageCrs(C2) = imageCrs(C1)  

 imageCrsDomain(C2) = imageCrsDomain(C1)  

 dimensionList(C2) = dimensionList(C1)  

 for all a ∈ dimensionList(C2): 
  crsSet(C2, a) = crsSet(C1, a)  
  dimensionType(C2, a) = dimensionType(C1, a) 

 

 for all a ∈ dimensionList(C2), c ∈ crsSet(C2, a): 
  domain(C2, a, c) = domain(C2, a, c) 

 

for all fields r ∈ rangeFieldNames(C2): 
 rangeFieldType(C2,r) = complex2  
  if rangeFieldType(C1,r) ∈ { complex, complex2 }, ran-
geFieldType(C2,r) = double  
  otherwise 

X 

 nullSet(C2)  =  nullSet(C1)  
 

 

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationDefault(C2, r) =  interpolationDefault(C1, r) 

 

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationSet(C2, r) =  interpolationSet(C1, r) 

 

 
The server shall respond with an exception if one of the coverage’s grid point values or 
its null values is not within the domain of the function to be applied to it. 

Example The following expression replaces all (nonnegative numeric) values of coverage C with their 
natural logarithm: 

ln( C ) 

24 
 



OGC 08-068r1 

7.1.18 boolExpr 

The boolExpr element specifies a unary induced Boolean operation. 

Let  

C1 be a coverageExpr 

Then, 

for any coverageExpr C2  
where C2 is one of 
  Cnot =  not C1 
 Cbit =  bit( C1 , n )  
where n is an expression evaluating to a nonnegative integer value 

C2 is defined as follows: 

 Coverage constituent Changed? 

 identifier(C2) = “” (empty string) X 

 for all p ∈ imageCrsDomain(C2): 
 value( Cnot , p ) =  not( value(C1,p) ) 
 value( Cbit, p ) =  (value(C1,p) >> value(n) ) mod 2 

X 

 imageCrs(C2) = imageCrs(C1)  

 imageCrsDomain(C2) = imageCrsDomain(C1)  

 dimensionList(C2) = dimensionList(C1)  

 for all a ∈ dimensionList(C2): 
 crsSet(C2, a) = crsSet(C1, a)  
  dimensionType(C2, a) = dimensionType(C1, a) 

 

 for all a ∈ dimensionList(C2), c ∈ crsSet(C2, a): 
  domain(C2, a, c) = domain(C2, a, c) 

 

 for all fields r ∈ rangeFieldNames(C2): 
 rangeieldType(C2,r) = boolean 

X 

 nullSet(Cnot) =  not( nullSet(C1) ) 
 nullSet(Cbit)  =  (nullSet(C1) >> value(n) ) mod 2 
where the resp. operation is applied componentwise to the set. An 
invalid operand (such as negative numbers in case of a square root 
operation) shall lead to a service exception. 

X 

 for all r ∈ rangeFieldNames(C2 ):  

 25
 



OGC 08-068r2 
 

  interpolationDefault(C2, r) =  interpolationDefault(C1, r) 

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationSet(C2, r) =  interpolationSet(C1, r) 

 

 
Example The following expression inverts all (assumed: Boolean) range field values of coverage C: 

not C 

NOTE The operation bit(a,b) extracts bit position b (assuming a binary representation) from int-
eger number a and shifts the resulting bit value to bit position 0. Hence, the resulting value is either 0 or 1. 

7.1.19 castExpr 

The castExpr element specifies a unary induced cast operation, that is: to change the 
range type of the coverage while leaving all other properties unchanged.  

NOTE Depending on the input and output types result possibly may suffer from a loss of accuracy 
through data type conversion. 

Let  

C1 be a coverageExpr, 
t be a range field type name. 

Then, 

for any coverageExpr C2  
where 
  C2 =  ( t ) C1 

C2 is defined as follows: 

 Coverage constituent Changed? 

 identifier(C2) = “” (empty string) X 

 for all p ∈ imageCrsDomain(C2): 
 value( C2 , p ) =  (t) value(C1,p) 

X 

 imageCrs(C2) = imageCrs(C1)  

 imageCrsDomain(C2) = imageCrsDomain(C1)  

 dimensionList(C2) = dimensionList(C1)  

 for all a ∈ dimensionList(C2): 
 crsSet(C2, a) = crsSet(C1, a)  
  dimensionType(C2, a) = dimensionType(C1, a) 

 

26 
 



OGC 08-068r1 

 for all a ∈ dimensionList(C2), c ∈ crsSet(C2, a): 
  domain(C2, a, c) = domain(C2, a, c) 

 

 for all fields r ∈ rangeFieldNames(C2): 
 rangeFieldType(C2,r) = t 

X 

 nullSet(C2) = (t) nullSet(C1 
where the resp. operation is applied componentwise to the set. An 
invalid operand (such as negative numbers in case of a square root 
operation) shall lead to a service exception. 

X 

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationDefault(C2, r) =  interpolationDefault(C1, r) 

 

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationSet(C2, r) =  interpolationSet(C1, r) 

 

 
The server shall respond with an exception if one of the coverage’s grid point values or 
its null values cannot be cast to the type specified (see Subclause 7.2.5). 

Example the result range type of the following expression will be char, i.e., 8 bit: 

(char) ( C / 2 ) 

7.1.20 fieldExpr 

The fieldExpr element specifies a unary induced field selection operation. Fields are se-
lected by their name, in accordance with the WCS range field subsetting operation. 

NOTE Due to the current restriction to atomic range fields, the result of a field selection has atomic 
values too. 

Let  

C1 be a coverageExpr, 
f be a fieldName appearing in rangeFieldNames(C1). 

Then, 

for any coverageExpr C2 
where 
  C2 =  C1 . f 

C2 is defined as follows: 

 Coverage constituent Changed? 

 identifier(C2) = “” (empty string) X 

 27
 



OGC 08-068r2 
 

 for all p ∈ imageCrsDomain(C2): 
 value( C2, p )  =  value( C1.f, p ) 

 

 imageCrs(C2) = imageCrs(C1)  

 ImageCrsDomain(C2) = imageCrsDomain(C1)  

 dimensionList(C2) = dimensionList(C1)  

 for all a ∈ dimensionList(C2): 
 crsSet(C2, a) = crsSet(C1, a)  
  dimensionType(C2, a) = dimensionType(C1, a) 

 

 for all a ∈ dimensionList(C2), c ∈ crsSet(C2, a): 
  domain(C2, a, c) = domain(C2, a, c) 

 

 rangeFieldType(C2,f) = rangeFieldType(C1,f) X 

 nullSet(C2) = nullSet(C1).f 
where the resp. operation is applied componentwise to the set. An 
invalid operand (such as negative numbers in case of a square root 
operation) shall lead to a service exception. 

X 

 interpolationDefault(C2, comp ) =  interpolationDefault(C1, f)  

 interpolationSet(C2, f ) =  interpolationSet(C1, f )  

 
Example Let C be a coverage with range type integer. Then the following request snippet describes a 
single-field, integer-type coverage where each grid point value contains the difference between red and 
green band:  

C.red - C.green 

7.1.21 binaryInducedExpr 

The binaryInducedExpr element specifies a binary induced operation, i.e., an operation 
involving two coverage-valued arguments.  

Both participating coverages must have the same number of range components; other-
wise the server shall respond with a service exception. 

The coverage range types shall be numeric. 

Let  

C1, C2 be coverageExprs, 
S1, S2 be scalarExprs, 
where 
 imageCrsDomain(C1,a) = imageCrsDomain(C2,a), 

28 
 



OGC 08-068r1 

 imageCrs(C1,a) = imageCrs(C2,a), 
 domain(C1,a) = domain(C2,a), 
 crsSet(C1,a) = crsSet(C2,a) for all a ∈ dimensionList(C2), 
 rangeFieldNames(C1) = rangeFieldNames(C2), 
 rangeType(C1,f) is cast-compatible with rangeType(C2,f) or  
   rangeType(C2,f) is cast-compatible with rangeType(C1,f) 
   for all f ∈ rangeFieldNames(C1),  
  nullSet(C1) ∩ nullSet(C2) ≠ {}. 

Then, 

for any coverageExpr C3 
where C3 is one of 
  CplusCC =  C1 + C2  
  CminCC =  C1 - C2  
  CmultCC =  C1 * C2 
  CdivCC =  C1 / C2 
  CandCC =  C1 and C2 
  CorCC =  C1 or C2 
  CxorCC =  C1 xor C2  
  CeqCC =  C1 = C2  
  CltCC =  C1 < C2  
  CgtCC =  C1 > C2  
  CleCC =  C1 <= C2  
  CgeCC =  C1 >= C2  
  CneCC =  C1 != C2  
  CovlCC =  C1 overlay C2 

 CplusSC =  S1 + C2  
  CminSC =  S1 - C2  
  CmultSC =  S1 * C2  
  CdivSC =  S1 / C2  
  CandSC =  S1 and C2  
  CorSC =  S1 or C2  
  CxorSC =  S1 xor C2  
  CeqSC =  S1 = C2  
  CltSC  =  S1 < C2  
  CgtSC =  S1 > C2  
  CleSC =  S1 <= C2  
  CgeSC =  S1 >= C2  
  CneSC =  S1 != C2  
  CovlSC =  S1 overlay C2 

 CplusCS =  C1 + S2  
  CmincS =  C1 - S2  
  CmultCS =  C1 * S2  

 29
 



OGC 08-068r2 
 

  CdivCS =  C1 / S2  
  CandCS =  C1 and S2  
  CorCS =  C1 or S2  
  CxorCS =  C1 xor S2  
  CeqCS =  C1 = S2  
  CltCS  =  C1 < S2  
  CgtCS =  C1 > S2  
  CleCS =  C1 <= S2  
  CgeCS =  C1 >= S2  
  CneCS =  C1 != S2  
  CovlCS =  C1 overlay S2 

C3 is defined as follows: 

 Coverage constituent Changed? 

 identifier(C3) = “” (empty string) X 

 for all p ∈ imageCrsDomain(C3): 
 value( CplusCC, p ) =  value(C1, p) + value(C2, p) 
 value( CminCC, p ) =  value(C1, p) - value(C2, p)  
 value( CmultCC, p ) =  value(C1, p) * value(C2, p)  
 value( CdivCC, p )  =  value(C1, p) / value(C2, p)  
 value( CandCC, p )  =  value(C1, p) and value(C2, p)  
 value( CorCC, p )  =  value(C1, p) or value(C2, p) 
 value( CxorCC, p )  =  value(C1, p) xor value(C2, p) 
 value( CeqCC, p )  =  value(C1, p) = value(C2, p) 
 value( CltCC, p )  =  value(C1, p) < value(C2, p) 
 value( CgtCC, p )  =  value(C1, p) > value(C2, p) 
 value( CleCC, p )  =  value(C1, p) <= value(C2, p) 
 value( CgeCC, p )  =  value(C1, p) >= value(C2, p) 
 value( CneCC, p )  =  value(C 1, p) != value(C2, p) 
 value( CovlCC, p )  =  value(C2, p)  if value(C1, p)=0 
   value(C1, p)  otherwise 

 value( CplusSC, p )  =  S1 + value(C2, p) 
 value( CminSC, p )  =  S1 - value(C2, p)  
 value( CmultSC, p )  =  S1 * value(C2, p)  
 value( CdivSC, p )  =  S1 / value(C2, p)  
 value( CandSC, p )  =  S1 and value(C2, p)  
 value( CorSC, p )  =  S1 or value(C2, p) 
 value( CxorSC, p )  =  S1 xor value(C2, p) 
 value( CeqSC, p )  =  S1 = value(C2, p) 
 value( CltSC, p )  =  S1 < value(C2, p) 
 value( CgtSC, p )  =  S1 > value(C2, p) 
 value( CleSC, p )  =  S1 <= value(C2, p) 
 value( CgeSC, p )  =  S1 >= value(C2, p) 

X 

30 
 



OGC 08-068r1 

 value( CneSC, p )  =  S1 != value(C2, p) 
 value( CovlSC, p )  =  value(C2, p)  if S1=0 
     S1  otherwise 

 value( CplusCS, p )  =  value(C1, p) + S2 
 value( CminCS, p )  =  value(C1, p) - S2  
 value( CmultCS, p )  =  value(C1, p) * S2  
 value( CdivCS, p )  =  value(C1, p) / S2  
 value( CandCS, p )  =  value(C1, p) and S2 
 value( CorCS, p )  =  value(C1, p) or S2 
 value( CxorCS, p )  =  value(C1, p) xor S2 
 value( CeqCS, p )  =  value(C1, p) = S2 
 value( CltCS, p )  =  value(C1, p) < S2  
 value( CgtCS, p )  =  value(C1, p) > S2  
 value( CleCS, p )  =  value(C1, p) <= S2 
 value( CgeCS, p )  =  value(C1, p) >= S2 
 value( CneCS, p )  =  value(C1, p) != S2 
 value( CovlCS, p )  =  S2  if value(C1, p)=0 
     value(C1, p)  otherwise 
Whenever necessary, appropriate cast operations are performed on 
the values prior to performing the binary value operation (cf. Sub-
clause 7.2.5). 

 ImageCrs(C3) = imageCrs(C1)  

 imageCrsDomain(C3) = imageCrsDomain(C1)  

 dimensionList(C2) = dimensionList(C1)  

 for all a ∈ dimensionList(C2): 
 crsSet(C3, a) = crsSet(C1, a)  
  dimensionType(C2, a) = dimensionType(C1, a) 

 

 for all a ∈ dimensionList(C3), c ∈ crsSet(C3, a): 
  domain(C3, a, c) = domain(C1, a, c) 

 

 for all r ∈ rangeFieldNames(C3): 

 rangeFieldType( CplusCC, r) is given by Section 7.2.5 
 rangeFieldType( CminCC, r)  is given by Section 7.2.5 
 rangeFieldType( CmultCC, r) is given by Section 7.2.5 
 rangeFieldType( CdivCC, r)  is given by Section 7.2.5 
 rangeFieldType( CandCC, r)  =  boolean 
 rangeFieldType( CorCC, r)  =  boolean 
 rangeFieldType( CxorCC, r)  =  boolean 
 rangeFieldType( CeqCC, r)  =  boolean 
 rangeFieldType( CltCC, r)  =  boolean 
 rangeFieldType( CgtCC, r)  =  boolean 

X 

 31
 



OGC 08-068r2 
 

 rangeFieldType( CleCC, r)  =  boolean 
 rangeFieldType( CgeCC, r)  =  boolean 
 rangeFieldType( CneCC, r)  =  boolean 
 rangeFieldType( CovlCC, r)  =  rangeFieldType( C1, r ) 

 rangeFieldType( CplusSC, r)  is given by Section 7.2.5 
 rangeFieldType( CminSC, r)  is given by Section 7.2.5 
 rangeFieldType( CmultSC, r)  is given by Section 7.2.5 
 rangeFieldType( CdivSC, r)   is given by Section 7.2.5 
 rangeFieldType( CandSC, r)  =  boolean 
 rangeFieldType( CorSC, r)   =  boolean 
 rangeFieldType( CxorSC, r)   =  boolean 
 rangeFieldType( CeqSC, r)   =  boolean 
 rangeFieldType( CltSC, r)   =  boolean 
 rangeFieldType( CgtSC, r)   =  boolean 
 rangeFieldType( CleSC, r)   =  boolean 
 rangeFieldType( CgeSC, r)   =  boolean 
 rangeFieldType( CneSC, r)   =  boolean 
 rangeFieldType( CovlSC, r)   =  rangeFieldType(C2) 

 rangeFieldType( CplusCS, r)  is determined by Table 5 
 rangeFieldType( CminCS, r)  is determined by Table 5 
 rangeFieldType( CmultCS, r)  is determined by Table 5 
 rangeFieldType( CdivCS, r)  is determined by Table 5 
 rangeFieldType( CandCS, r)  =  boolean 
 rangeFieldType( CorCS, r)  =  boolean 
 rangeFieldType( CxorCS, r)  =  boolean 
 rangeFieldType( CeqCS, r)  =  boolean 
 rangeFieldType( CltCS, r)  =  boolean 
 rangeFieldType( CgtCS, r)  =  boolean 
 rangeFieldType( CleCS, r)  =  boolean 
 rangeFieldType( CgeCS, r)  =  boolean 
 rangeFieldType( CneCS, r)  =  boolean 
 rangeFieldType( CovlCS, r)  =  boolean 

 nullSet( C3 ) =  ∅ if the result is boolean, 
 nullSet( C3 ) =  nullSet(C1) ∩ nullSet(C2) otherwise 

X 

 for all r ∈ rangeFieldNames(C3 ): 
 interpolationDefault(C3, r) = none 

X 

 for all r ∈ rangeFieldNames(C3 ): 
 interpolationSet(C3, r) = { none } 

X 

 
Example  The following expression describes a coverage composed of the sum of the red, green, and blue 
fields of coverage C:  

32 
 



OGC 08-068r1 

C.red + C.green + C.blue 

7.1.22 rangeConstructorExpr 

The rangeConstructorExpr, an n-ary induced operation, allows to build coverages with 
compound range structures. To this end, coverage range field expressions enumerated are 
combined into one coverage.  

All input coverages must match wrt. domains and CRSs. An input coverage range field 
may be listed more than once. 

The names of the range fields generated by the operation shall be given by the names 
prefixed to each component expression. 

Let  

n be an integer with n≥1, 
C1, …, Cn be coverageExprs,  
f1, …, fn be fieldNames 
where, for 1≤i,j≤n, 
  fi ∈ rangeFieldNames(Ci),  
  imageCrs(Ci) = imageCrs(Cj),  
  imageCrsDomain(Ci) = imageCrsDomain(Cj),  
  crsSet(Ci) = crsSet(Cj),  
  domain(Ci,ai,ci) = domain(Cj,aj,cj) 
   for all ai∈dimensionList(Ci), aj∈dimensionList(Cj), ci∈crsSet(Ci), 
cj∈crsSet(Cj). 

Then, 

for any coverageExpr C’ 
where C’ is one of  
  { f1 : C1 ; … ; fn : Cn } 
 struct { f1 : C1 ; … ; fn : Cn } 

C’ is defined as follows: 

 Coverage constituent Changed? 

 identifier(C’) = “” (empty string) X 

 for all p ∈ imageCrsDomain(C’), i ∈ {1, …, n}: 
 value(C’.(i-1), p )  =  value( Ci.fi, p ) 

X 

 imageCrs(C’) = imageCrs(C1)  

 imageCrsDomain(C’) = imageCrsDomain(C1)  

 33
 



OGC 08-068r2 
 

 dimensionList(C2) = dimensionList(C1)  

 for all a ∈ dimensionList(C2): 
 crsSet(C’, a) = crsSet(C1, a)  
  dimensionType(C2, a) = dimensionType(C1, a) 

 

 for all a ∈ dimensionList(C1), c ∈ crsSet(C1): 
  domain(C’, a, c) = domain(C1, a, c) 

 

for all fields r ∈{ f1, …, fn}: 
 rangeFieldType( C3, r ) = rangeFieldType( Ci, fi ) 

X 

 nullSet(C’) = nullSet(C1) × … × nullSet(Cn) X 

 for all i in {1, …, n}: 
  interpolationDefault(C’, fi ) = interpolationDefault(Ci, fi ) 

X 

 for all i in {1, …, n}: 
  interpolationSet(C’, fi ) =  interpolationSet(Ci, fi ) 

X 

 
Example 1: The expression below does a false color encoding by combining near-infrared, red, and green 
bands into a 3-band image of 8-bit channels each, which can be visually interpreted as RGB: 

struct  
{ red:   (char) L.nir;  
  green: (char) L.red; 
  blue:  (char) L.green  
} 

Example 2: The following expression transforms a greyscale image G containing a range field 
panchromatic into an RGB-structured image: 

{ red:   G.panchromatic; 
  green: G.panchromatic; 
  blue:  G.panchromatic  
} 

7.1.23 subsetExpr 

The subsetExpr element specifies spatial and temporal domain subsetting. It encom-
passes spatial and temporal trimming (i.e., constraining the result coverage domain to a 
subinterval, Subclause 7.1.24), slicing (i.e., cutting out a hyperplane from a coverage, 
Subclause 7.1.26), extending (Subclause 7.1.25), and scaling (Subclause 7.1.27) of a 
coverage expression. 

All of the subsetExpr elements allow to make use of coordinate reference systems other 
than a coverage’s image CRS. A coverage’s individual mapping from some supported 
CRS coordinates to its ImageCRS coordinates does not need to be disclosed by the serv-
er, hence coordinate transformation should be considered a “black box” by the client. 

34 
 



OGC 08-068r1 

NOTE 1  The special case that subsetting leads to a single point remaining still resembles a coverage by 
definition; this coverage is viewed as being of dimension 0. 

NOTE 2 Range subsetting is accomplished via the unary induced fieldExpr (cf. Subclause 7.1.20). 

7.1.24 trimExpr 

The trimExpr element extracts a subset from a given coverage expression along the di-
mension indicated, specified by a lower and upper bound for each dimension affected. 
Interval limits can be expressed in the coverage’s image CRS or any CRS which the the 
coverage supports. 

Lower as well as upper limits must lie inside the coverage’s domain. 

For syntactic convenience, both array-style addressing using brackets and function-style 
syntax are provided; both are equivalent in semantics. 

Let  

C1 be a coverageExpr, 
n be an integer with 0≤n, 
a1,…,an be pairwise distinct dimensionNames with  ai ∈ dimensionName-
Set(C1) for 1≤i≤n, 
crs1,…,crsn be crsNames with  crsi ∈ crsList(C1) for 1≤i≤n, 
(lo1:hi1),…,(lon:hin) be dimensionIntervalExprs with loi≤hii for 1≤i≤n. 

Then, 

for any coverageExpr C2 
where C2 is one of 
 Cbracket  = C1 [ p1, …, pn ] 
  Cfunc  = trim ( C1, { p1, …, pn } ) 
with  
 pi is one of 
  pimg,i =  ai ( loi : hii ) 
 pcrs,i =  ai : crsi ( loi : hii ) 

C2 is defined as follows: 

 

 

Coverage constituent Changed? 

 identifier(C2) = “” (empty string) X 

 for all p ∈ imageCrsDomain(C2):  

 35
 



OGC 08-068r2 
 

 value(C2, p ) =  value(C1,p) 

 imageCrs(C2) = imageCrs(C1)  

 dimensionList(C2) = dimensionList(C1)  

 for all a ∈ dimensionList(C2): 
 if a = ai for some i 
  then imageCrsDomain(C2 , a )  =  (loi,img : hii,img ) 
  else imageCrsDomain(C2 , a )  =  imageCrsDomain(C1 , a ) 
where (loi,img : hii,img ) = (loi:hii) if no CRS is indicated, and the 
transform from crsi into the image CRS if crsi is indicated. 

X 

 for all a ∈ dimensionList(C2): 
 crsSet(C2, a) = crsSet(C1, a)  
  dimensionType(C2, a) = dimensionType(C1, a) 

 

 for all a ∈ dimensionList(C2), c ∈ crsSet(C2): 
 if a = ai for some i 
  then domain(C2 , a, c )  =  (loi,c : hii,c ) 
  else domain(C2 , a, c )  =  domain(C1 , a, c ) 
where (loi,c:hii,c) represent the dimension boundaries (loi:hii) 
transformed of (loi:hii) from the C2 image CRS into CRS c. 

X 

for all r ∈ rangeFieldNames(C2): 
 rangeFieldType( C2, r ) = rangeFieldType(C1, r) 

 

 nullSet(C2) = nullSet(C1)  

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationDefault(C2, r) =  interpolationDefault(C1, r) 

 

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationSet(C2, r) =  interpolationSet(C1, r) 

 

 
NOTE 1 It is possible to mix different CRSs in one trim operation, however each dimension must be 
addressed in exactly one CRS (either image CRS or another supported CRS). 

NOTE 2 A trim operation might simultaneously perform x/y trimming expressed in some geographic 
coordinate CRS and time trimming in a time CRS. 

Example The following are syntactically valid, equivalent trim expressions: 

C[ x : ”urn:ogc:def:crs:EPSG::4326” (-180 : +180), 
   y : ”urn:ogc:def:crs:EPSG::4326” (-90 : 90) ] 

trim( C, 
      { x: ”urn:ogc:def:crs:EPSG::4326” (-180 : +180), 
        y: ”urn:ogc:def:crs:EPSG::4326” (-90 : 90) 

36 
 



OGC 08-068r1 

      } 
    ) 

7.1.25 extendExpr 

The extendExpr element extends a coverage to the bounding box indicated. The new 
grid points are filled with one of the coverage’s null values. If  the coverage’s null value 
set is empty then the server shall throw an exception. 

There is no restriction on the position and size of the new bounding box; in particular, it 
does not need to lie outside the coverage; it may intersect with the coverage; it may lie 
completely inside the coverage; it may not intersect the coverage at all (in which case a 
coverage completely filled with null values will be generated).  

NOTE In this sense the extendExpr is a generalization of the trimExpr; still the trimExpr should be 
used whenever the application needs to be sure that a proper subsetting has to take place. 

Let  

C1 be a coverageExpr, 
n be an integer with 0≤n, 
a1,…,an be pairwise distinct dimensionNames with  ai ∈ dimensionName-
Set(C1) for 1≤i≤n, 
crs1,…,crsn be crsNames with  crsi ∈ crsList(C1) for 1≤i≤n, 
 (lo1:hi1),…,(lon:hin) be dimensionIntervalExprs with loi≤hii for 1≤i≤n. 

Then, 

for any coverageExpr C2 
where 
 C2  =  extend ( C1, { p1, …, pn } ) 
with  
 pi is one of 
  pimg,i =  ai ( loi : hii ) 
 pcrs,i =  ai : crsi ( loi : hii ) 

C2 is defined as follows: 

Coverage constituent Changed? 

 identifier(C2) = “” (empty string) X 

 for all p ∈ imageCrsDomain(C2): 
 value( C2, p ) =  value(C1,p) for p ∈ imageCrsDomain(C1)  
 value( C2, p ) =  n  for n∈nullSet(C1), nullSet(C1)≠∅ 

X 

 imageCrs(C2) = imageCrs(C1)  

 37
 



OGC 08-068r2 
 

 dimensionList(C2) = dimensionList(C1)  

 for all a ∈ dimensionList(C2): 
 if a = ai for some i 
  then imageCrsDomain(C2 , a )  =  (loi,img : hii,img ) 
  else imageCrsDomain(C2 , a )  =  imageCrsDomain(C1 , a ) 
where (loi,img : hii,img ) = (loi:hii) if no CRS is indicated, and the 
transform of (loi:hii) from crsi into the C2 image CRS if crsi is 
indicated. 

X 

 for all a ∈ dimensionList(C2): 
 crsSet(C2, a) = crsSet(C1, a)  
  dimensionType(C2, a) = dimensionType(C1, a) 

 

 for all a ∈ dimensionList(C2), c ∈ crsSet(C2): 
 if a = ai for some i 
  then domain(C2 , a, c )  =  (loi,c : hii,c ) 
  else domain(C2 , a, c )  =  domain(C1 , a, c ) 
where (loi,c:hii,c) represent the dimension boundaries (loi:hii) 
transformed from their image CRS into CRS c. 

X 

for all r ∈ rangeFieldNames(C2): 
 rangeFieldType( C2, r ) = rangeFieldType(C1, r) 

 

 nullSet(C2) = nullSet(C1)  

 for all r ∈ rangeFieldNames(C2 ): 
   interpolationDefault(C2, r) =  interpolationDefault(C1, r) 

 

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationSet(C2, r) =  interpolationSet(C1, r) 

 

 
NOTE A server may decide to restrict the CRSs available on the result, as not all CRSs may be tech-
nically appropriate any more. 

Example The following is a syntactically valid extend expression: 

extend( C, { x ( -200 : +200 ) } ) 

7.1.26 sliceExpr 

The sliceExpr element extracts a spatial slice (i.e., a hyperplane) from a given coverage 
expression along one of its dimensions, specified by one or more slicing dimensions and 
a slicing position thereon. For each slicing dimension indicated, the resulting coverage 
has a dimension reduced by 1; its dimensions are the dimensions of the original coverage, 
in the same sequence, with the section dimension being removed from the list. CRSs not 
used by any remaining dimension are removed from the coverage’s CRS set. 

38 
 



OGC 08-068r1 

The slicing coordinates shall lie inside the coverage’s domain. 

For syntactic convenience, both array-style addressing using brackets and function-style 
syntax are provided; both are equivalent in semantics. 

Let  

C1 be a coverageExpr, 
n be an integer with 0≤n, 
a1,…,an be pairwise distinct dimensionNames with  ai ∈ dimensionName-
Set(C1) for 1≤i≤n, 
crs1,…,crsn be crsNames with  crsi ∈ crsList(C1) for 1≤i≤n, 
s1,…,sn be dimensionPoints for 1≤i≤n. 

Then, 

for any coverageExpr C2 
where C2 is one of 
 Cbracket  = C1 [ S1, …, Sn ] 
 Cfunc = slice( C1, , { S1, …, Sn } ) 
with  
 Si is one of 
 Simg,i =  ai(si) 
 Scrs,i =  ai(si)crsi 

C2 is defined as follows: 

Coverage constituent Changed? 

 identifier(C2) = “” (empty string) X 

 for all p ∈ imageCrsDomain(C1)  
 such that 
 for all a ∈ dimensionList(C1): 
  if a∈{a1,…,an} 
  then 
   let pa be that component of p addressing dimen-
sion a 
   pa’ = si for Simg,i 
   pa’ = si transformed from crsi for Scrs,i 
  else 
   let pa be that component of p addressing dimen-
sion a 
   let pa’ be that component of p’ addressing di-
mension a 
   pa, pa’ ∈ imageCrsDomain(C1,a) 

 

 39
 



OGC 08-068r2 
 

value(C2, p ) =  value(C1,p’) 

 imageCrs(C2) = imageCrs(C1)  

 dimensionList(C2) = dimensionList(C1) \ {a1,…,an} X 

 for all a ∈ dimensionList(C2): 
  imageCrsDomain(C2, a )  =  imageCrsDomain(C1, a ) 

X 

 for all a ∈ dimensionList(C2): 
 crsSet(C2, a) = crsSet(C1, a)   
      \  ( {crs1,…,crsn} \ crsSet(C1, a) ) 
  dimensionType(C2, a) = dimensionType(C1, a) 

X 

for all a ∈ dimensionList(C1) \ {a1,…,an}, c ∈ crsSet(C2, a): 
  domain(C2, a, c) = domain(C1, a, c) 

X 

 for all r ∈ rangeFieldNames(C2): 
 rangeFieldType( C2, r ) = rangeFieldType(C1, r) 

 

 NullSet(C2) = nullSet(C1)  

 for all r ∈ rangeFieldNames(C2 ): 
   interpolationDefault(C2, r) =  interpolationDefault(C1, r) 

 

 for all r ∈ rangeFieldNames(C2 ): 
   interpolationSet(C2, r) =  interpolationSet(C1, r) 

 

 
NOTE 1 A server may decide to restrict the CRSs available on the result, as not all CRSs may be ap-
propriate any more. 

NOTE 2 In a future version of this document this function is likely to be .extended with multi-
dimensional slicing. 

Example The following are syntactically valid, equivalent slice expressions: 

C[ x ( 120 ) ] 

slice( C, { x ( 120 ) } ) 

7.1.27 scaleExpr 

The scaleExpr element performs scaling along a subset of the source coverage’s dimen-
sions. For each of the coverage’s range fields, an interpolation method can be chosen 
from the coverage’s interpolation method list. If no interpolation is indicated for a field, 
then this field’s default interpolation method shall be used.  

A service exception shall be raised if for any of the coverage’s range fields no appropri-
ate interpolation method is available for the resampling/interpolation performed in the 
course of the transformation. 

40 
 



OGC 08-068r1 

Let 

C1 be a coverageExpr, 
m, n be integers with 0≤m and 0≤n, 
a1,…,am be pairwise distinct dimensionNames with  ai ∈ dimensionName-
Set(C1) for 1≤i≤m, 
(lo1:hi1),…,(lom:him) be dimensionPoint pairs with loi≤hii for 1≤i≤m, 
f1, ..., fn be pairwise distinct fieldNames, it1, ..., itn be interpolationTypes, 
nr1, ..., nrn be nullResistances with fi∈rangeFieldNames(C1)  
 and  (iti,nri)∈interpolationSet(C1,fi) for 1≤i≤n. 

Then, 

For any coverageExpr C2, 
where 
 C2  =  scale ( 
    C1, 
    { p1, …, pm } , 
    { f1(it1,nr1), ..., fn(itn,nrn) } 
  ) 
with  
 pi is one of 
 pimg,i =  ai(loi:hii) 
 pcrs,i =  ai(loi:hii)crsi 

C2 is defined as follows: 

Coverage constituent Changed? 

 identifier(C2) = “” (empty string) X 

 for all p ∈ imageCrsDomain(C2): 
 value(C2, p ) is obtained by rescaling the coverage along di-
mensions ai such that the coverage’s extent along dimension ai is 
set to (loi:hii), expressed in the coverage’s image CRS; all other 
dimensions remain unaffected.  

For every range field fi listed, interpolation type iti and null re-
sistance nri are applied during evaluation; for all range fields not 
listed their resp. default interpolation is applied. 

X 

 imageCrs(C2) = imageCrs(C1)  

 dimensionList(C2) = dimensionList(C1)  

 for all a ∈ dimensionList(C1): 
 if a = ai for some i 
  then imageCrsDomain(C2 , a )  =  (loi :hii ) 

X 

 41
 



OGC 08-068r2 
 

  else imageCrsDomain(C2 , a )  =  imageCrsDomain(C1 , a ) 

 for all a ∈ dimensionList(C2): 
 crsSet(C2, a) = crsSet(C1, a)  
  dimensionType(C2, a) = dimensionType(C1, a) 

 

for all a ∈ dimensionList(C2), c ∈ crsSet(C2, a): 
  domain(C2,a,c) = domain(C1,a,c) 

 

 for all r ∈ rangeFieldNames(C2): 
 rangeFieldType( C2, r ) = rangeFieldType(C1, r) 

 

 nullSet(C2) = nullSet(C1)  

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationDefault(C2, r) =  interpolationDefault(C1, r) 

 

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationSet(C2, r) =  interpolationSet(C1, r) 

 

 

NOTE Scaling regularly involves range interpolation, hence numerical effects have to be expected. 

Example The following expression performs x/y scaling of some coverage C – which has one single 
range field, temperature – using interpolation type cubic and null resistance full in both x and 
y dimension, assuming that the range field supports this method: 

scale( 
    C, 
    { x ( lox : hix ) , y ( loy : hiy )  }, 
    { red ( cubic , full ), nir ( linear, half ) } 
) 

If the default interpolation method is undefined and no interpolation method is indicated 
expressly then the server shall respond with a runtime exception. 

7.1.28 crsTransformExpr 

The element performs reprojection of a coverage. For each dimension, a separate CRS 
can be indicated; for any dimension for which no CRS is indicated, no reprojection will 
be performed. For the resampling which usually is incurred the interpolation method and 
null resistance can be indicated per range field; for fields not mentioned the default will 
be applied. 

NOTE 1 This changes the range values (e.g., pixel radiometry). 

NOTE 2 A service may refuse to accept some CRS combinations (e.g., different CRSs handling for x 
and y dimension). 

42 
 



OGC 08-068r1 

NOTE 3 As any coverage bearing a CRS beyond its image CRS is stored in some CRS, there will nor-
mally be a parameter combination which retrieves the coverage as stored, without any reprojection opera-
tion required. 

Let 

C1 be a coverageExpr, 
m, n be integers with 1≤m and 0≤n, 
a1,…,am be pairwise distinct dimensionNames with  ai ∈ dimensionName-
Set(C1) for 1≤i≤m, 
crs1,…,crsm be pairwise distinct crsNames with  crsi ∈ crsList(C1) for 
1≤i≤m, 
f1, ..., fn be pairwise distinct fieldNames,  
it1, ..., itn be interpolationTypes,  
nr1, ..., nrn be nullResistances with fi∈rangeFieldNames(C1)  
 and  (iti,nri) ∈ interpolationSet(C1,fi) for 1≤i≤n. 

Then, 

for any coverageExpr C2 
where 
 C2 = crsTransform( 
   C1, , 
   { a1:crs1, …, am:crsm } ) 
   { f1(it1,nr1), ..., fn(itn,nrn) } 
  ) 

C2 is defined as follows: 

Coverage constituent Changed? 

 identifier(C2) = “” (empty string) X 

 for all p ∈ imageCrsDomain(C2): 
 value(C2, p ) is obtained by reprojecting coverage C1 along 
dimensions ai into CRS crsi; all other dimensions remain unaf-
fected.  
 For every range field fi listed, interpolation type iti and null 
resistance nri are applied during evaluation; for all range fields not 
listed their resp. default interpolation is applied. 

X 

 imageCrs(C2) = imageCrs(C1)  

 dimensionList(C2) = dimensionList(C1)  

 for all a ∈ dimensionList(C1): 
 imageCrsDomain(C2 , a )  =  imageCrsDomain(C1 , a ) 

 

 43
 



OGC 08-068r2 
 

 for all a ∈ dimensionList(C2): 
 crsSet(C2, a) = crsSet(C1, a)  
  dimensionType(C2, a) = dimensionType(C1, a) 

 

for all a ∈ dimensionList(C2), c ∈ crsSet(C2, a): 
  domain(C2,a,c) = domain(C1,a,c) 

 

 for all r ∈ rangeFieldNames(C2): 
 rangeFieldType( C2, r ) = rangeFieldType(C1, r) 

 

 nullSet(C2) = nullSet(C1)  

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationDefault(C2, r) =  interpolationDefault(C1, r) 

 

 for all r ∈ rangeFieldNames(C2 ): 
  interpolationSet(C2, r) =  interpolationSet(C1, r) 

 

Example The following expression transforms coverage C (which is assumed to have x and y dimen-
sions) into the CRS identified by urn:ogc:def:crs:EPSG:6.6:63266405. Linear interpolation with null resis-
tance “none” is applied to range field red if necessary, to all other range fields the default itenrpolation and 
null resistance is applied. 

crsTransform( C, 
              { x: “ urn:ogc:def:crs:EPSG::63266405”,  
                y: “ urn:ogc:def:crs:EPSG::63266405” 
              }, 
              { red(linear,none) 
            } 

7.1.29 coverageConstructorExpr 

The coverageConstructorExpr element allows to create a d-dimensional coverage for 
some d≥1.  

The domain definition consists, for each dimension, of a unique dimension name plus 
lower and upper bound of the coverage, expressed in a fixed image CRS and using integ-
er coordinates; for this image CRS one of the identifiers listed in [05-096r1] Table 1 
shall be used.  

The coverage’s content is defined by an expression whose type defines the coverage 
range type. 

This coverage has no other CRS associated beyond the abovementioned image CRS; fur-
ther, it has no null values and interpolation methods associated. Finally, all other metada-
ta are undefined. To set specific metadata for this new coverage the setMatadataExpr 
(Subclause 7.1.11) is available. 

NOTE This constructor is useful  

 whenever the coverage is too large to be described as a constant or  

44 
 



OGC 08-068r1 

 when the coverage's range values are derived from some other source (such as in the course of a 
histogram computation, see example below). 

Let 

f be a fieldName, 
d be an integer with d>0, 
axisi be pairwise distinct dimensionTypes for 1≤i≤d4, 
namei be pairwise distinct variableNames for 1≤i≤d, which additionally, in the 
request on hand, are not used already as a variable in this expression’s scope, 
loi and hii be integers for 1≤i≤d with loi ≤ hii, 
V  be a scalarExpr possibly containing occurrences of namei. 

Then, 

For any coverageExpr C 
where  
  C  = coverage f 
  over name1 axis1 (lo1:hi1), 
    …, 
    named axisd (lod:hid) 
  values  V 

C is defined as follows: 

Coverage constituent Changed? 

 identifier(C) = “” (empty string) X 

 for all p ∈ imageCrsDomain(C): 
 value(C, p ) = V’ 
where expression V’ is obtained from expression V by substituting 
all occurrences of namei by v where (namei,v)∈p 

X 

 imageCrs(C) = c0  
(i.e., the WCPS standard image CRS, see Clause 6) 

X 

 imageCrsDomain(C )  is set to a d-dimensional cube with dimen-
sion names name1…named where the extent of dimension namei 
ranges from loi to hii (including these boundary values). 

X 

 dimensionList(C2) = { name1 ,…, named } X 

 for all a ∈ dimensionList(C): 
 crsSet(C, a) = {}, 

X 

                                                 
4 In the future, introduction of a GeneralDomain concept is planned for WCS which, among others, will allow an arbi-
trary number of so-called “abstract axes”, i.e., axes without spatio-temporal semantics. More than one dimension of 
this type will be allowed. 

 45
 



OGC 08-068r2 
 

  dimensionType(C, a) = if  a = namei then axis1 for 1≤i≤d 

for all a ∈ dimensionList(C), c ∈ crsSet(C, a): 
  domain(C, a, c) = undefined5 

X 

 for r ∈ { f }, 
  rangeFieldType(C,r) = type(V) 
 i.e., the single range field’s type is equal to the result type of ex-
pression V 

X 

 nullSet(C) = {} X 

 for all r ∈ rangeFieldNames(C ): 
   interpolationDefault(C, r) =  none 

X 

 for all r ∈ rangeFieldNames(C ): 
   interpolationSet(C, r) =  {} 

X 

 

Example The expression below represents a 2-D greyscale image with a diagonal shade from white to 
black (the cast operator forces the floating point division result into an integer): 

coverage greyshade 
over     px x ( 0 : 255 ), 
         py y ( 0 : 255 ) 
values   (unsigned char) ( px + py ) / 2 

Example The expression below computes a 256-bucket histogram over band b some coverage C of un-
known domain and dimension6: 

coverage histogram 
over     bucket x ( 0 : 255 ) 
values   count( C.b = bucket ) 

NOTE In future, WCPS is expected to support “abstract” axes with non-spatiotemporal semantics, 
which is the better choice for a histogram. Until then, some existing axis type like “x” is recommended. 

7.1.30 coverageConstantExpr 

The coverageConstantExpr element allows to create a d-dimensional coverage, for 
some d≥1, having one range field component with point values immediately given in the 
expression.  

The domain definition consists, for each dimension, of a unique dimension name plus 
lower and upper bound of the coverage, expressed in a fixed image CRS and using integ-
                                                 
5 Note that, due to the empty crsSet, this “loop” anyway will not be “entered”. 
6 In the future, introduction of a GeneralDomain concept is planned for WCS which, among others, will allow an arbi-
trary number of so-called “abstract axes”, i.e., axes without spatio-temporal semantics. With the availability of abstract 
axes, dimension type “x” will be replaced by dimension type “abstract” in the code piece displayed. 

46 
 



OGC 08-068r1 

er coordinates; for this image CRS one of the identifiers listed in [05-096r1] Table 1 
shall be used.  

The coverage’s content is defined by a sequence of values. The narrowest range type en-
compassing all values encountered shall be its range type. 

If the number of range components or their type turns out incompatible for any two 
points, or if the number of point values provided does not match with the domain extent 
specified, then the server shall respond with an exception. 

This coverage has no other CRS associated beyond the abovementioned image CRS; fur-
ther, it has no null values and interpolation methods associated. Finally, all other metada-
ta are undefined. To set specific metadata for this new coverage the setMetadataExpr 
(Subclause 7.1.11) is available. 

NOTE This constructor is useful for supplying a moderately sized coverage,e.g., as filter kernel. 

Let 

f be a fieldName, 
d be an integer with d>0, 
axisi be pairwise distinct dimensionTypes for 1≤i≤d7, 
namei be pairwise distinct variableNames for 1≤i≤d, which additionally, in the 
request on hand, are not used already as a variable in this expression’s scope, 
loi and hii be integers for 1≤i≤d with loi ≤ hii, 
S  be a  scalarExpr possibly. 

Then, 

For any coverageExpr C 
where  
  C  = coverage f 
  over name1 axis1 (lo1:hi1), 
    …, 
    named axisd (lod:hid) 
  valueset S 

C is defined as follows: 

Coverage constituent Changed? 

 identifier(C) = “” (empty string) X 

 for all p ∈ imageCrsDomain(C): 
 value(C, p ) is determined by assigning each value in turn to a 

X 

                                                 
7 In the future, introduction of a GeneralDomain concept is planned for WCS which, among others, will allow an arbi-
trary number of so-called “abstract axes”, i.e., axes without spatio-temporal semantics. More than one dimension of 
this type will be allowed. 

 47
 



OGC 08-068r2 
 

grid point location, whereby assignment proceeds per dimension 
from the lowest to the highest coordinate, and loops over the grid 
points with the first dimension making up for the innermost loop, 
the second dimension for the next-to-innermost loop, etc., and the 
last dimension for the outermost loop. 

 imageCrs(C) = c0  
(i.e., the WCPS standard image CRS, see Clause 6) 

X 

 imageCrsDomain(C )  is set to a d-dimensional cube with dimen-
sion names name1…named where the extent of dimension namei 
ranges from loi to hii (including these boundary values). 

X 

 dimensionList(C2) = { name1 ,…, named } X 

 for all a ∈ dimensionList(C): 
 crsSet(C, a) = {}, 
  dimensionType(C, a) = if  a = namei then axis1 for 1≤i≤d 

X 

for all a ∈ dimensionList(C), c ∈ crsSet(C, a): 
  domain(C, a, c) = undefined8 

X 

 for r ∈ { f }, 
  rangeFieldType(C,r) = type(V) 
 i.e., the single range field’s type is equal to the result type of ex-
pression V 

X 

 nullSet(C) = {} X 

 for all r ∈ rangeFieldNames(C ): 
   interpolationDefault(C, r) =  none 

X 

 for all r ∈ rangeFieldNames(C ): 
   interpolationSet(C, r) =  {} 

X 

 

Example For a Sobel filter, a 3x3 filter kernel can be provided by the expression below. 

coverage   Sobel3x3 
over       px x ( -1 : 1 ), 
           py y ( -1 : 1 ) 
value list <  1,  2,  1, 
              0,  0,  0, 
             -1, -2, -1 
           >   

                                                 
8 Note that, due to the empty crsSet, this “loop” anyway will not be “entered”. 

48 
 



OGC 08-068r1 

7.1.31 condenseExpr 

A condenseExpr is either a reduceExpr (see Subclause7.1.33) or a generalCondense-
Expr (see Subclause 7.1.32). It takes a coverage and summarizes its values using some 
summarization function. The value returned is scalar. 

Whenever one of the point values (“pixels”, etc.) participating in a condense operation is 
equal to one of the null values of its coverage then the result of the operation shall be one 
of the values in the coverage’s null value set. If no null value is available then the the 
server shall respond with a service exception. 

7.1.32 generalCondenseExpr 

The general generalCondenseExpr consolidates the grid point values of a coverage 
along selected dimensions to a scalar value based on the condensing operation indicated. 
It iterates over a given domain while combining the result values of the scalarExprs 
through the condenseOpType indicated. Admissible condenseOpTypes are the binary 
operations +, *, max, min, and, and or. 

Let  

op be a condenseOpType, 
n be some integer with n≥0, 
d be some integer with d>0, 
axisi be dimensionNames for 1≤i≤d, 
namei be pairwise distinct variableNames for 1≤i≤d which, in the request on 
hand, are not used already as a variable in this expression’s scope, 
loi and hii be integerExprs for 1≤i≤d with loi ≤ hii, 
Cj be coverageExprs for 1≤j≤n, 
P be a booleanExpr possibly containing occurrences of namei and Cj, 
V be a scalarExpr possibly containing occurrences of namei and Cj 
where 
  1≤i≤d. 

Then, 

For any scalarExpr S 
where  

 S is one of 
 S’  =  condense op 
    over name1 axis1 (lo1:hi1), 
          …, 
          named axisd (lod:hid) 
    using V 
 S”  =  condense op 
    over name1 axis1 (lo1:hi1), 
          …, 

 49
 



OGC 08-068r2 
 

          named axisd (lod:hid) 
    where P 
    using V 

S is constructed as follows: 

Let S = neutral element of type(V); 
for all name1 ∈ {lo1,… ,hi1} 
  for all name2 ∈ {lo2,… ,hi2} 
   … 
    for all named ∈ {lod,… ,hid} 
    if (expression P is present) 
     then 
      let predicate P’ be obtained from evaluating expression  
      P by substituting all occurrences of namei by its current 
      value where namei occurring in a coordinate 
     position of Cj is interpreted as coordinates in the image  
     CRS of Cj; 
     else 
      P’ = true; 
    if (P’) 
     then 
      let V’ be obtained from evaluating expression V  
      by substituting all occurrences of namei by its current  
      value where namei occurring in a coordinate 
     position of Cj is interpreted as coordinates in the image  
     CRS of Cj; 
     S = S op value(V’); 
return S 

 

NOTE 1 Condensers are heavily used, among others, in these two situations: 

 To collapse Boolean-valued coverage expressions into scalar Boolean values so that they can be 
used in predicates. 

 In conjunction with the coverageConstructorExpr (see Subclause 7.1.29) to phrase high-level 
imaging, signal processing, and statistical operations. 

NOTE 2 The additional expressive power of condenseExpr over reduceExpr is twofold: 

 A WCPS implementation may offer further summarisation functions, as long as these are com-
mutative and associative. 

 The condenseExpr gives explicit access to the coordinate values; this makes summarisation con-
siderably more powerful (see example below). 

Example For a filter kernel k, the condenser must summarise not only over the grid point under inspec-
tion, but also some neighbourhood. The following applies a 3x3 filter kernel to band b of some coverage C 
with extent x0…x1/y0…y1; note that the result image is defined to have an x and y dimension. 

50 
 



OGC 08-068r1 

coverage filteredImage 
over     px x ( x0 : x1 ), 
         py y ( y0 : y1 ) 
values   condense + 
         over    kx x ( -1 : +1 ), 
                 ky y ( -1 : +1 ) 
         using   C.b[ kx + px , ky + py ] * k[ kx , ky ] 

where k is a 3x3 matrix like 

1 2 1 
0 0 0 
-1 -2 -1 

 

NOTE See coverageConstantExpr for a way to specify the k matrix. 

7.1.33 reduceExpr 

A reduceExpr element derives a summary value from the coverage passed; in this sense 
it “reduces” a coverage to a scalar value. A reduceExpr is either an add, avg, min, max, 
count, some, or all operation.  

Table 4 – reduceExpr definition via generalCondenseExpr 

reduceExpr definition9 Meaning 

add(a) = 
 condense + 
 over p1 D1(imageCrsDomain(a,D1)), 
      …, 
      pd Dd(imageCrsDomain(a,D1)), 
 using a[p1 , …, pd ] 

sum over all points in a 

avg(a) = 
 add(a) / | imageCrsDomain(a) | 

Average of all points in a 

min(a) = 
 condense min 
 over p1 D1(imageCrsDomain(a,D1)), 
      …, 
      pd Dd(imageCrsDomain(a,D1)) 
 using a[px] 

Minimum of all points in a 

max(a) = 
 condense max 
 over p1 D1(imageCrsDomain(a,D1)), 
      …, 
      pd Dd(imageCrsDomain(a,D1)) 

Maximum of all points in a 

                                                 
9 a is a numeric, b a Boolean coverageExpr 

 51
 



OGC 08-068r2 
 

 using a[x] 

count(b) = 
 condense + 
 over p1 D1(imageCrsDomain(a,D1)), 
      …, 
      pd Dd(imageCrsDomain(a,D1)) 
 where b[x] 
 using 1 

Number of points in b 

some(b) = 
 condense or 
 over p1 D1(imageCrsDomain(a,D1)), 
      …, 
      pd Dd(imageCrsDomain(a,D1)) 
 using b[x] 

is there any point in b with value true? 

all(b) = 
 condense and 
 over p1 D1(imageCrsDomain(a,D1)), 
      …, 
      pd Dd(imageCrsDomain(a,D1)) 
 using b[x] 

do all points of b have value true? 

 

7.2 Expression evaluation 

This Sublause defines additional rules for ProcessCoverages expression evaluation. 

7.2.1 Evaluation sequence 

A Web Coverage Processing Server shall evaluate coverage expressions from left to 
right. 

7.2.2 Nesting 

A Web Coverage Processing Server shall allow to nest all operators, constructors, and 
functions arbitrarily, provided that each sub-expression's result type matches the required 
type at the position where the sub-expression occurs. This holds without limitation for all 
arithmetic, Boolean, String, and coverage-valued expressions. 

7.2.3 Parentheses 

A Web Coverage Processing Server shall allow use of parentheses to enforce a particular 
evaluation sequence. 

Let 

C1 and C2 be coverageExprs 

52 
 



OGC 08-068r1 

Then, 

For any coverageExpr C2 
where 
 C2 = ( C1 ) 

C2 is defined as yielding the same result as C1. 

Example C * ( C > 0 ) 

7.2.4 Operator precedence rules 

In case of ambiguities in the syntactical analysis of a request, operators shall have the 
following precedence (listed in descending strength of binding): 

 Range field selection, trimming, slicing 

 unary – 

 unary arithmetic, trigonometric, and exponential functions 

 *, / 

 +, - 

 <, <=, >, >=, !=, = 

 and 

 or, xor 

 ":" (interval constructor), condense, marray 

 overlay 

In all remaining cases evaluation is done left to right. 

7.2.5 Range type compatibility and extension 

A range type t1 is said to be cast-compatible with a range type t2 iff the following con-
ditions hold: 

 Both range types, t1 and t2, have the same number of field elements, say d; 

 For each range field element position i with 1≤i≤d, the ith range field type f1,i 
of t1 is cast-compatible with the ith range field type f2,i of t2. 

A range field type f1 is said to be cast-compatible with a range field type f2 iff f2 can be 
cast to f1, whereby casting of f2 to f1 is defined as looking up f2 in Table 5 and replac-

 53
 



OGC 08-068r2 
 

ing it by its right-hand neighbour type or, if it is the last type in line, by the first type of 
the next line. This is repeated until either f1 is matched, or the end of the Table 5 is 
reached. Type f1 can be cast to type f2 if the casting procedure terminates with finding 
t2, otherwise the cast is not possible. 

Extending Boolean to (signed or unsigned) short shall map false to 0 and true to 1. 

On both arguments to binary operations casting shall be attempted until both argument 
types are equal; if such a common type can be found, then this shall be the binary opera-
tion result type; otherwise, an exception shall be thrown. 

Example For three single-field coverages F, I, and B with range types float, integer, and 
Boolean, resp., the result type of the following expression is float: 

F + I + B 

Table 5 – Type extension sequence. 

Type extension rules 
 

Boolean > char 
char > Boolean 

Boolean > unsigned char 
unsigned char > Boolean 

char > short 
char > unsigned short 
unsigned char > short 

unsigned char > unsigned short 
short > int 

short > unsigned int 
unsigned short > int 

unsigned short > unsigned int 
int > long 

int > unsigned long 
unsigned int > long 

unsigned int > unsigned long 
long > float 

float > double 
float > complex 

double > complex2 
complex > complex2 

 

The type of each of the operands of a multiplicative operator (+, -, *, /) shall be a type 
that can be extended to a numeric numeric type, or an exception occurs. The type of a 
multiplicative expression is the extended type of its operands. If this promoted type is an 
integer type, then integer arithmetic shall be performed; if this promoted type is a float-
ing-point type, then floating-point arithmetic shall be performed; if this promoted type is 
a complex type, then complex arithmetic shall be performed. 

54 
 



OGC 08-068r1 

NOTE Explicit and implicit casts should be used with caution, as unintended consequences can arise. 
Data can be lost when floating-point representations are converted to integral representations as the frac-
tional components of the floating-point values will be truncated (rounded down). Conversely, converting 
from an integral representation to a floating-point one can also lose precision, since the floating-point type 
may be unable to represent the integer exactly (for example, float might be an IEEE 754 single precision 
type, which cannot represent the integer 16777217 exactly, while a 32-bit integer type can). This can lead 
to situations such as storing the same integer value into two variables of type int and type float which re-
turn false if compared for equality. 

Whenever rounding from floating-point to integer numbers is required, rounding towards 
zero shall be applied. 

Example For a Boolean single-field coverage B, and an integer single-field coverage I, the following 
expression will evaluate to some integer value: 

count( I * B ) 

Before executing any binary operation where the two operands are of different type a cast 
operation shall be attempted to achieve equal types. The result type of each of the binary 
induced operations (see Section 7.1.21) addition, subtraction, multiplication, and division 
shall be equal to the common type of the input operands. 

If a cast is attempted or implicitly needed, but not possible according to the above rules, 
then an exception shall be reported.  

NOTE The cast operation is similar to that found in many programming languages, such as C/C++. 

7.3 Evaluation exceptions 

Whenever a coverage expression cannot be evaluated according to the rules specified in 
Clauses 7.1 and 7.2, a Web Coverage Processing Server shall respond with an exception. 

Example The following expressions will lead to an exception when used in a ProcessCoverages request 
(reasons: division by zero; square root of a negative number): 

C / 0 

sqrt( - abs( C ) ) 

7.4 processCoveragesExpr response 

The response to a request sending a processCoveragesExpr is one of the following: 

Depending on its result type, the normal response to a valid ProcessCoverages request 
shall consist of one of the following alternatives: 

 A (possibly empty) set of coverages. 

 A scalar (where scalar summarizes all non-coverage type data, such as numbers, 
strings, URLs) or a structure composed of scalars (via structs, lists, etc., possibly 
nested). 

 55
 



OGC 08-068r2 
 

 An exception. 

Encoding of single coverages is governed by the encodedCoverageExpr (see Section 
7.1.4). Encoding of scalar structures and exceptions as well as the representation of the 
overall response shall be governed by a separate, additional protocol specification. 

NOTE WCS [OGC 08-059r3] specifies a response protocol suitable for WCPS results. An embedding 
of WCPS into WPS, including its specific request and delivery structures, is under work.  

56 
 



OGC 08-068r1 

Annex A 
(normative) 

 
Abstract Test Suite 

The Abstract Test Suite for WCPS is provided in [OGC 08-069r2]. 

 57
 



OGC 08-068r2 
 

Annex B 
(normative) 

 
WCPS Expression Syntax 

B.1 Overview 

This Annex summarizes the WCPS expression syntax. It is described in EBNF grammar 
syntax according to [IETF RFC 2616]. Underlined tokens represent literals which appear 
“as is” in a valid WCPS expression (“terminal symbols”), underlined tokens in italics 
represent sub-expressions to be substituted according to the grammar production rules 
(“non-terminals”). Any number of whitespace characters (blank, tabulator, newline) may 
appear between tokens as long as parsing is unambiguous. 

Example Between language tokens (such as “for”) and names there must be at least one whitespace cha-
racter, whereas between names and non-alphanumeric tokens (such as opening parenthesis, “(“), no whi-
tespace is required. 

Meta symbols used are as follows: 

- brackets (“[…]”) denote optional elements which may occur or be left out; 

- an asterisk (“*”) denotes that an arbitrary number of repetitions of the following 
element can be chosen, including none at all; 

- a vertical bar (“|”) denotes alternatives from which exactly one must be chosen; 

- Double slashes (“//”) begin comments which continue until the end of the line. 

B.2 WCPS syntax 

processCoveragesExpr: 
     for variableName in ( coverageList ) 
          *( , variableName in ( coverageList ) )  
      [ where booleanScalarExpr ] 
      return processingExpr 

coverageList: 
     coverageName *( , coverageName ) 

processingExpr: 
     encodedCoverageExpr 
   | storeExpr 
   | scalarExpr 

encodedCoverageExpr: 
     encode ( coverageExpr, formatName ) 
   | encode ( coverageExpr, formatName, extraParams ) 

58 
 



OGC 08-068r1 

formatName: 
     stringConstant 

extraParams: 
     stringConstant 

storeExpr: 
     store ( encodedCoverageExpr ) 

scalarExpr: 
     metaDataExpr 
   | generalCondenseExpr 
   | booleanScalarExpr 
   | numericScalarExpr 
    | stringScalarExpr 
   | ( scalarExpr ) 

booleanScalarExpr: 
   | booleanScalarExpr and booleanScalarTerm 
   | booleanScalarExpr or booleanScalarTerm 
   | booleanScalarExpr xor booleanScalarTerm 
    | booleanScalarTerm 

booleanScalarTerm: 
   | booleanScalarTerm and booleanScalarFactor 
   | booleanScalarTerm or booleanScalarFactor 
   | booleanScalarTerm xor booleanScalarFactor 
    | booleanScalarFactor 

booleanScalarFactor: 
    | numericScalarExpr compOp numericScalarExpr 
   | stringScalarExpr compOp stringScalarExpr 
   | not booleanScalarExpr 
   | booleanConstant 

numericScalarExpr: 
   | numericScalarExpr addOp numericScalarTerm 
   | numericScalarTerm 

numericScalarTerm: 
      numericScalarTerm multOp numericScalarFactor 
    | numericScalarFactor 
    | - numericScalarFactor 
    | round ( numericScalarFactor ) 

numericScalarFactor: 
    | ( numericScalarExpr ) 
    | integerConstant 
    | floatConstant 
    | complexConstant 
   | condenseExpr 

 59
 



OGC 08-068r2 
 

compOp: 
     compOpEqual 
   | compOpGreaterLess 

compOpEqual: 
      = 
    | != 

compOpGreaterLess: 
     > 
   | >= 
    | < 
    | <= 

multOp: 
     * 
   | / 

addOp: 
     + 
   | - 

stringScalarExpr:  
     metaDataExpr    // currently only identifier() allowed 
   | stringConstant 
 

metaDataExpr: 
     identifier ( coverageExpr ) 
   | imageCrs ( coverageExpr ) 
   | imageCrsDomain ( coverageExpr ) 
   | imageCrsDomain ( coverageExpr , axisName ) 
   | crsSet ( coverageExpr ) 
   | domain ( coverageName , axisName , crsName ) 
   | nullSet ( coverageExpr ) 
   | interpolationDefault ( coverageExpr , fieldName ) 
   | interpolationSet ( coverageExpr , fieldName ) 

setMetaDataExpr: 
      setIdentifier ( stringConstant ) 
   | setCrsSet ( coverageExpr , 
        { [ crsName *( , crsName ) ] } ) 
   | setNullSet ( coverageExpr ,  
       { [ rangeExpr *( , rangeExpr ) ] } ) 
   | setInterpolationDefault ( coverageExpr , fieldName 
        , interpolationMethod ) 
   | setInterpolationSet ( coverageExpr , fieldName , 
        { [ interpolationMethod 
            *( , interpolationMethod ) ] } ) 

rangeExpr: 
      struct { fieldname : scalarExpr 
                *( , fieldname : scalarExpr ) } 

60 
 



OGC 08-068r1 

coverageExpr:  
     coverageName 
   | setMetaDataExpr 
   | inducedExpr 
   | subsetExpr 
   | crsTransformExpr 
   | scaleExpr 
   | coverageConstExpr 
   | coverageConstructorExpr 
   | ( coverageExpr ) 

inducedExpr: 
   | unaryInducedExpr 
   | binaryInducedExpr 
   | rangeConstructorExpr 

unaryInducedExpr:  
     unaryArithmeticExpr 
   | exponentialExpr 
   | trigonometricExpr 
   | booleanExpr 
   | castExpr 
   | fieldExpr 

unaryArithmeticExpr:  
     + coverageExpr 
   | - coverageExpr 
   | sqrt ( coverageExpr ) 
   | abs ( coverageExpr ) 

exponentialExpr:  
     exp ( coverageExpr ) 
   | log ( coverageExpr ) 
   | ln ( coverageExpr ) 

trigonometricExpr:  
     sin ( coverageExpr ) 
   | cos ( coverageExpr ) 
   | tan ( coverageExpr ) 
   | sinh ( coverageExpr ) 
   | cosh ( coverageExpr ) 
   | tanh ( coverageExpr ) 
   | arcsin ( coverageExpr ) 
   | arccos ( coverageExpr ) 
   | arctan ( coverageExpr ) 

booleanExpr:  
     not coverageExpr 
   | bit ( coverageExpr , integerExpr ) 

castExpr:  
     ( rangeType ) coverageExpr 

 61
 



OGC 08-068r2 
 

rangeType: 
     bool 
   | char 
   | unsigned char 
   | short 
   | unsigned short 
   | long 
   | unsigned long 
   | float 
   | double 
   | complex 
   | complex2 

fieldExpr:  
     coverageExpr . fieldName 

binaryInducedExpr: 
   | coverageExpr binaryInducedOp coverageExpr 
   | coverageExpr binaryInducedOp scalarExpr 
   | scalarExpr binaryInducedOp coverageExpr 

binaryInducedOp: 
   | +  
   | -  
   | *  
   | /  
   | and  
   | or  
   | xor  
   | =  
   | <  
   | >  
   | <=  
   | >=  
   | !=  
   | overlay  

rangeConstructorExpr: 
      [ struct ] { fieldName : coverageExpr 
                 *( ; fieldName : coverageExpr ) } 

subsetExpr:  
   | trimExpr 
   | sliceExpr 
   | extendExpr 

trimExpr: 
     coverageExpr [ dimensionIntervalList ] 
   | trim ( coverageExpr , { dimensionIntervalList } ) 

sliceExpr: 
     coverageExpr [ dimensionPointList ] 
   | slice ( coverageExpr , { dimensionPointList } ) 

62 
 



OGC 08-068r1 

extendExpr: 
     extend ( coverageExpr , dimensionIntervalList ) 

scaleExpr: 
     scale ( coverageExpr , dimensionIntervalList , 
              fieldInterpolationList ) 

crsTransformExpr: 
     crsTransform ( coverageExpr , 
                        dimensionIntervalList , 
                        fieldInterpolationList ) 

dimensionPointList: 
     dimensionPointElement *( , dimensionPointElement ) 

dimensionPointElement: 
     axisName [ : crsName ] ( dimensionPoint ) 

dimensionPoint: 
     scalarExpr 

dimensionIntervalList: 
      dimensionIntervalElement 
      *( , dimensionIntervalElement ) 

dimensionIntervalElement: 
   axisName [ : crsName ] ( dimensionIntervalExpr ) 

dimensionIntervalExpr: 
     scalarExpr : scalarExpr  
    | domain ( coverageName , axisName , crsName ) 

fieldInterpolationList: 
     { fieldInterpolationListElement 
        *( , fieldInterpolationListElement ) } 

fieldInterpolationListElement: 
     fieldName : interpolationMethod 

interpolationMethod:   // taken from WCS [OGC 07-067r5] 
     ( interpolationType : nullResistance ) 

interpolationType:    // taken from WCS [OGC 07-067r5] Table I.7 
     nearest 
   | linear 
   | quadratic 
   | cubic 

nullResistance:     // taken from WCS [OGC 07-067r5]  
     full 
   | none 
   | half 
   | other 

 63
 



OGC 08-068r2 
 

coverageConstructorExpr: 
     coverage coverageName 
     over axisIterator *( , axisIterator ) 
     values scalarExpr 

axisIterator: 
       variableName axisName ( intervalExpr ) 

intervalExpr: 
      integerExpr : integerExpr 
    | imageCrsDomain ( coverageName , axisName ) 

coverageConstantExpr: 
     coverage coverageName 
     over axisIterator *( , axisIterator ) 
     value list < constant *( ; constant ) > 

condenseExpr: 
     reduceExpr 
   | generalCondenseExpr 

reduceExpr: 
     all ( coverageExpr ) 
   | some ( coverageExpr ) 
   | count ( coverageExpr ) 
   | add ( coverageExpr ) 
   | avg ( coverageExpr ) 
   | min ( coverageExpr ) 
   | max ( coverageExpr ) 

generalCondenseExpr: 
     condense condenseOpType 
     over axisIterator *( , axisIterator ) 
     [ where booleanScalarExpr ] 
      using scalarExpr 

condenseOpType: 
     + 
   | * 
   | max 
   | min 
   | and 
   | or 

variableName: 
     name     // see below for restrictions 

coverageName: 
     name     // coverage identifier as in WCS [OGC 07-067r5] 

crsName: 
      stringConstant // containing a valid CRS name 

64 
 



OGC 08-068r1 

axisName10: 
     x 
    | y 
    | z 
    | t 
    | name     // where name is none of the other variants 

fieldName: 
     name     // as defined in WCS [OGC 07-067r5] Table 19 

constant: 
      stringConstant | booleanConstant 
    | integerConstant | floatConstant | complexConstant 

complexConstant: 
      ( floatConstant , floatConstant ) 

A variableName shall be a consecutive sequence of characters where the first character 
shall be either an alphabetical character or the “$” character and the remaining characters 
consist of decimal digits, upper case alphabetical characters, lower case alphabetical cha-
racters, underscore (“_”), and nothing else. The length of an identifier shall be at least 1. 

NOTE 1 The regular expression describing an identifier is: [$a-zA-Z_][0-9a-zA-Z_]*. 

NOTE 2 WCS [OGC 07-067r5] allows more freedom in the choice of identifiers; for the sake of sim-
plicity this is tightened for now, but may be adapted to the WCS identifier definition in a future version of 
this standard. 

A booleanConstant shall represent a logical truth value expressed as one of the liter-
als “true” and “false” resp., whereby upper and lower case characters shall not be distin-
guished. 

An integerConstant shall represent an integer number expressed in either decimal, 
octal (with a “0” prefix), or hexadecimal notation (with a “0x” or “0X” prefix). 

A floatConstant shall represent a floating point number following the syntax of the 
Java programming language. 

A stringConstant shall represent a character sequence expressed by enclosing it into 
double quotes (‘”´). 

                                                 
10 In the future, introduction of a General Domain concept is planned for WCS which, among others, will allow an 
arbitrary number of so-called “abstract axes”, i.e., axes without spatio-temporal semantics. DimensionType, then, will 
be extended with the additional dimension type “abstract”.  

 65
 



OGC 08-068r2 
 

66 
 

Bibliography  

[1] Ritter, G., Wilson, J., Davidson, J.: Image Algebra: An Overview. Computer Vi-
sion, Graphics, and Image Processing, 49(3)1990, pp. 297-331 

[2] Baumann, P.: A Database Array Algebra for Spatio-Temporal Data and Beyond. 
The Fourth International Workshop on Next Generation Information Technologies 
and Systems (NGITS '99), July 5-7, 1999, Zikhron Yaakov, Israel, Lecture Notes 
on Computer Science 1649, Springer Verlag, pp. 76 - 93 

 


	1 Scope 
	2 Compliance
	3 Normative references
	4 Terms and definitions
	5 Conventions
	5.1 Symbols (and abbreviated terms)
	5.2 UML notation
	5.3 Platform-neutral and platform-specific specifications

	6 Conceptual coverage model
	6.1 Coverage model
	6.1.1 Coverages
	6.1.2 Dimensions
	6.1.3 Locations
	6.1.4 Domain 
	6.1.5 Range values and types
	6.1.6 Null and interpolation

	6.2 Coverage probing functions summary
	6.3 Restrictions relative to the WCS coverage model

	7 WCPS coverage processing language
	7.1 Expression syntax
	7.1.1 processCoveragesExpr
	7.1.2 processingExpr
	7.1.3 storeCoverageExpr
	7.1.4 encodedCoverageExpr
	7.1.5 scalarExpr
	7.1.6 booleanScalarExpr
	7.1.7 numericScalarExpr
	7.1.8 stringScalarExpr
	7.1.9 coverageExpr
	7.1.10 getMetaDataExpr
	7.1.11 setMetaDataExpr
	7.1.12 coverageIdentifier
	7.1.13 inducedExpr
	7.1.14 unaryInducedExpr
	7.1.15 unaryArithmeticExpr
	7.1.16 trigonometricExpr
	7.1.17 exponentialExpr
	7.1.18 boolExpr
	7.1.19 castExpr
	7.1.20 fieldExpr
	7.1.21 binaryInducedExpr
	7.1.22 rangeConstructorExpr
	7.1.23 subsetExpr
	7.1.24 trimExpr
	7.1.25 extendExpr
	7.1.26 sliceExpr
	7.1.27 scaleExpr
	7.1.28 crsTransformExpr
	7.1.29 coverageConstructorExpr
	7.1.30 coverageConstantExpr
	7.1.31 condenseExpr
	7.1.32 generalCondenseExpr
	7.1.33 reduceExpr

	7.2 Expression evaluation
	7.2.1 Evaluation sequence
	7.2.2 Nesting
	7.2.3 Parentheses
	7.2.4 Operator precedence rules
	7.2.5 Range type compatibility and extension

	7.3 Evaluation exceptions
	7.4 processCoveragesExpr response




